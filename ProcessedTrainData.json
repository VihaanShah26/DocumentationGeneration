{"code_tokens": ["def", "settext", "(", "self", ",", "text", ",", "cls", "=", "'current'", ")", ":", "self", ".", "replace", "(", "TextContent", ",", "value", "=", "text", ",", "cls", "=", "cls", ")"], "docstring_tokens": ["Set", "the", "text", "for", "this", "element", "."]}
{"code_tokens": ["def", "setdocument", "(", "self", ",", "doc", ")", ":", "assert", "isinstance", "(", "doc", ",", "Document", ")", "if", "not", "self", ".", "doc", ":", "self", ".", "doc", "=", "doc", "if", "self", ".", "id", ":", "if", "self", ".", "id", "in", "doc", ":", "raise", "DuplicateIDError", "(", "self", ".", "id", ")", "else", ":", "self", ".", "doc", ".", "index", "[", "id", "]", "=", "self", "for", "e", "in", "self", ":", "#recursive for all children", "if", "isinstance", "(", "e", ",", "AbstractElement", ")", ":", "e", ".", "setdocument", "(", "doc", ")"], "docstring_tokens": ["Associate", "a", "document", "with", "this", "element", "."]}
{"code_tokens": ["def", "addable", "(", "Class", ",", "parent", ",", "set", "=", "None", ",", "raiseexceptions", "=", "True", ")", ":", "if", "not", "parent", ".", "__class__", ".", "accepts", "(", "Class", ",", "raiseexceptions", ",", "parent", ")", ":", "return", "False", "if", "Class", ".", "OCCURRENCES", ">", "0", ":", "#check if the parent doesn't have too many already", "count", "=", "parent", ".", "count", "(", "Class", ",", "None", ",", "True", ",", "[", "True", ",", "AbstractStructureElement", "]", ")", "#never descend into embedded structure annotatioton", "if", "count", ">=", "Class", ".", "OCCURRENCES", ":", "if", "raiseexceptions", ":", "if", "parent", ".", "id", ":", "extra", "=", "' (id='", "+", "parent", ".", "id", "+", "')'", "else", ":", "extra", "=", "''", "raise", "DuplicateAnnotationError", "(", "\"Unable to add another object of type \"", "+", "Class", ".", "__name__", "+", "\" to \"", "+", "parent", ".", "__class__", ".", "__name__", "+", "\" \"", "+", "extra", "+", "\". There are already \"", "+", "str", "(", "count", ")", "+", "\" instances of this class, which is the maximum.\"", ")", "else", ":", "return", "False", "if", "Class", ".", "OCCURRENCES_PER_SET", ">", "0", "and", "set", "and", "Class", ".", "REQUIRED_ATTRIBS", "and", "Attrib", ".", "CLASS", "in", "Class", ".", "REQUIRED_ATTRIBS", ":", "count", "=", "parent", ".", "count", "(", "Class", ",", "set", ",", "True", ",", "[", "True", ",", "AbstractStructureElement", "]", ")", "if", "count", ">=", "Class", ".", "OCCURRENCES_PER_SET", ":", "if", "raiseexceptions", ":", "if", "parent", ".", "id", ":", "extra", "=", "' (id='", "+", "parent", ".", "id", "+", "')'", "else", ":", "extra", "=", "''", "raise", "DuplicateAnnotationError", "(", "\"Unable to add another object of set \"", "+", "set", "+", "\" and type \"", "+", "Class", ".", "__name__", "+", "\" to \"", "+", "parent", ".", "__class__", ".", "__name__", "+", "\" \"", "+", "extra", "+", "\". There are already \"", "+", "str", "(", "count", ")", "+", "\" instances of this class, which is the maximum for the set.\"", ")", "else", ":", "return", "False", "return", "True"], "docstring_tokens": ["Tests", "whether", "a", "new", "element", "of", "this", "class", "can", "be", "added", "to", "the", "parent", "."]}
{"code_tokens": ["def", "postappend", "(", "self", ")", ":", "#If the element was not associated with a document yet, do so now (and for all unassociated children:", "if", "not", "self", ".", "doc", "and", "self", ".", "parent", ".", "doc", ":", "self", ".", "setdocument", "(", "self", ".", "parent", ".", "doc", ")", "if", "self", ".", "doc", "and", "self", ".", "doc", ".", "deepvalidation", ":", "self", ".", "deepvalidation", "(", ")"], "docstring_tokens": ["This", "method", "will", "be", "called", "after", "an", "element", "is", "added", "to", "another", "and", "does", "some", "checks", "."]}
{"code_tokens": ["def", "updatetext", "(", "self", ")", ":", "if", "self", ".", "TEXTCONTAINER", ":", "s", "=", "\"\"", "for", "child", "in", "self", ":", "if", "isinstance", "(", "child", ",", "AbstractElement", ")", ":", "child", ".", "updatetext", "(", ")", "s", "+=", "child", ".", "text", "(", ")", "elif", "isstring", "(", "child", ")", ":", "s", "+=", "child", "self", ".", "data", "=", "[", "s", "]"], "docstring_tokens": ["Recompute", "textual", "value", "based", "on", "the", "text", "content", "of", "the", "children", ".", "Only", "supported", "on", "elements", "that", "are", "a", "TEXTCONTAINER"]}
{"code_tokens": ["def", "ancestors", "(", "self", ",", "Class", "=", "None", ")", ":", "e", "=", "self", "while", "e", ":", "if", "e", ".", "parent", ":", "e", "=", "e", ".", "parent", "if", "not", "Class", "or", "isinstance", "(", "e", ",", "Class", ")", ":", "yield", "e", "elif", "isinstance", "(", "Class", ",", "tuple", ")", ":", "for", "C", "in", "Class", ":", "if", "isinstance", "(", "e", ",", "C", ")", ":", "yield", "e", "else", ":", "break"], "docstring_tokens": ["Generator", "yielding", "all", "ancestors", "of", "this", "element", "effectively", "back", "-", "tracing", "its", "path", "to", "the", "root", "element", ".", "A", "tuple", "of", "multiple", "classes", "may", "be", "specified", "."]}
{"code_tokens": ["def", "ancestor", "(", "self", ",", "*", "Classes", ")", ":", "for", "e", "in", "self", ".", "ancestors", "(", "tuple", "(", "Classes", ")", ")", ":", "return", "e", "raise", "NoSuchAnnotation"], "docstring_tokens": ["Find", "the", "most", "immediate", "ancestor", "of", "the", "specified", "type", "multiple", "classes", "may", "be", "specified", "."]}
{"code_tokens": ["def", "json", "(", "self", ",", "attribs", "=", "None", ",", "recurse", "=", "True", ",", "ignorelist", "=", "False", ")", ":", "jsonnode", "=", "{", "}", "jsonnode", "[", "'type'", "]", "=", "self", ".", "XMLTAG", "if", "self", ".", "id", ":", "jsonnode", "[", "'id'", "]", "=", "self", ".", "id", "if", "self", ".", "set", ":", "jsonnode", "[", "'set'", "]", "=", "self", ".", "set", "if", "self", ".", "cls", ":", "jsonnode", "[", "'class'", "]", "=", "self", ".", "cls", "if", "self", ".", "annotator", ":", "jsonnode", "[", "'annotator'", "]", "=", "self", ".", "annotator", "if", "self", ".", "annotatortype", ":", "if", "self", ".", "annotatortype", "==", "AnnotatorType", ".", "AUTO", ":", "jsonnode", "[", "'annotatortype'", "]", "=", "\"auto\"", "elif", "self", ".", "annotatortype", "==", "AnnotatorType", ".", "MANUAL", ":", "jsonnode", "[", "'annotatortype'", "]", "=", "\"manual\"", "if", "self", ".", "confidence", "is", "not", "None", ":", "jsonnode", "[", "'confidence'", "]", "=", "self", ".", "confidence", "if", "self", ".", "n", ":", "jsonnode", "[", "'n'", "]", "=", "self", ".", "n", "if", "self", ".", "auth", ":", "jsonnode", "[", "'auth'", "]", "=", "self", ".", "auth", "if", "self", ".", "datetime", ":", "jsonnode", "[", "'datetime'", "]", "=", "self", ".", "datetime", ".", "strftime", "(", "\"%Y-%m-%dT%H:%M:%S\"", ")", "if", "recurse", ":", "#pylint: disable=too-many-nested-blocks", "jsonnode", "[", "'children'", "]", "=", "[", "]", "if", "self", ".", "TEXTCONTAINER", ":", "jsonnode", "[", "'text'", "]", "=", "self", ".", "text", "(", ")", "if", "self", ".", "PHONCONTAINER", ":", "jsonnode", "[", "'phon'", "]", "=", "self", ".", "phon", "(", ")", "for", "child", "in", "self", ":", "if", "self", ".", "TEXTCONTAINER", "and", "isstring", "(", "child", ")", ":", "jsonnode", "[", "'children'", "]", ".", "append", "(", "child", ")", "elif", "not", "self", ".", "PHONCONTAINER", ":", "#check ignore list", "ignore", "=", "False", "if", "ignorelist", ":", "for", "e", "in", "ignorelist", ":", "if", "isinstance", "(", "child", ",", "e", ")", ":", "ignore", "=", "True", "break", "if", "not", "ignore", ":", "jsonnode", "[", "'children'", "]", ".", "append", "(", "child", ".", "json", "(", "attribs", ",", "recurse", ",", "ignorelist", ")", ")", "if", "attribs", ":", "for", "attrib", "in", "attribs", ":", "jsonnode", "[", "attrib", "]", "=", "attribs", "return", "jsonnode"], "docstring_tokens": ["Serialises", "the", "FoLiA", "element", "and", "all", "its", "contents", "to", "a", "Python", "dictionary", "suitable", "for", "serialisation", "to", "JSON", "."]}
{"code_tokens": ["def", "xmlstring", "(", "self", ",", "pretty_print", "=", "False", ")", ":", "s", "=", "ElementTree", ".", "tostring", "(", "self", ".", "xml", "(", ")", ",", "xml_declaration", "=", "False", ",", "pretty_print", "=", "pretty_print", ",", "encoding", "=", "'utf-8'", ")", "if", "sys", ".", "version", "<", "'3'", ":", "if", "isinstance", "(", "s", ",", "str", ")", ":", "s", "=", "unicode", "(", "s", ",", "'utf-8'", ")", "#pylint: disable=undefined-variable", "else", ":", "if", "isinstance", "(", "s", ",", "bytes", ")", ":", "s", "=", "str", "(", "s", ",", "'utf-8'", ")", "s", "=", "s", ".", "replace", "(", "'ns0:'", ",", "''", ")", "#ugly patch to get rid of namespace prefix", "s", "=", "s", ".", "replace", "(", "':ns0'", ",", "''", ")", "return", "s"], "docstring_tokens": ["Serialises", "this", "FoLiA", "element", "and", "all", "its", "contents", "to", "XML", "."]}
{"code_tokens": ["def", "select", "(", "self", ",", "Class", ",", "set", "=", "None", ",", "recursive", "=", "True", ",", "ignore", "=", "True", ",", "node", "=", "None", ")", ":", "#pylint: disable=bad-classmethod-argument,redefined-builtin", "#if ignorelist is True:", "#    ignorelist = default_ignore", "if", "not", "node", ":", "node", "=", "self", "for", "e", "in", "self", ".", "data", ":", "#pylint: disable=too-many-nested-blocks", "if", "(", "not", "self", ".", "TEXTCONTAINER", "and", "not", "self", ".", "PHONCONTAINER", ")", "or", "isinstance", "(", "e", ",", "AbstractElement", ")", ":", "if", "ignore", "is", "True", ":", "try", ":", "if", "not", "e", ".", "auth", ":", "continue", "except", "AttributeError", ":", "#not all elements have auth attribute..", "pass", "elif", "ignore", ":", "#list", "doignore", "=", "False", "for", "c", "in", "ignore", ":", "if", "c", "is", "True", ":", "try", ":", "if", "not", "e", ".", "auth", ":", "doignore", "=", "True", "break", "except", "AttributeError", ":", "#not all elements have auth attribute..", "pass", "elif", "c", "==", "e", ".", "__class__", "or", "issubclass", "(", "e", ".", "__class__", ",", "c", ")", ":", "doignore", "=", "True", "break", "if", "doignore", ":", "continue", "if", "isinstance", "(", "e", ",", "Class", ")", ":", "if", "not", "set", "is", "None", ":", "try", ":", "if", "e", ".", "set", "!=", "set", ":", "continue", "except", "AttributeError", ":", "continue", "yield", "e", "if", "recursive", ":", "for", "e2", "in", "e", ".", "select", "(", "Class", ",", "set", ",", "recursive", ",", "ignore", ",", "e", ")", ":", "if", "not", "set", "is", "None", ":", "try", ":", "if", "e2", ".", "set", "!=", "set", ":", "continue", "except", "AttributeError", ":", "continue", "yield", "e2"], "docstring_tokens": ["Select", "child", "elements", "of", "the", "specified", "class", "."]}
{"code_tokens": ["def", "getmetadata", "(", "self", ",", "key", "=", "None", ")", ":", "if", "self", ".", "metadata", ":", "d", "=", "self", ".", "doc", ".", "submetadata", "[", "self", ".", "metadata", "]", "elif", "self", ".", "parent", ":", "d", "=", "self", ".", "parent", ".", "getmetadata", "(", ")", "elif", "self", ".", "doc", ":", "d", "=", "self", ".", "doc", ".", "metadata", "else", ":", "return", "None", "if", "key", ":", "return", "d", "[", "key", "]", "else", ":", "return", "d"], "docstring_tokens": ["Get", "the", "metadata", "that", "applies", "to", "this", "element", "automatically", "inherited", "from", "parent", "elements"]}
{"code_tokens": ["def", "getindex", "(", "self", ",", "child", ",", "recursive", "=", "True", ",", "ignore", "=", "True", ")", ":", "#breadth first search", "for", "i", ",", "c", "in", "enumerate", "(", "self", ".", "data", ")", ":", "if", "c", "is", "child", ":", "return", "i", "if", "recursive", ":", "#pylint: disable=too-many-nested-blocks", "for", "i", ",", "c", "in", "enumerate", "(", "self", ".", "data", ")", ":", "if", "ignore", "is", "True", ":", "try", ":", "if", "not", "c", ".", "auth", ":", "continue", "except", "AttributeError", ":", "#not all elements have auth attribute..", "pass", "elif", "ignore", ":", "#list", "doignore", "=", "False", "for", "e", "in", "ignore", ":", "if", "e", "is", "True", ":", "try", ":", "if", "not", "c", ".", "auth", ":", "doignore", "=", "True", "break", "except", "AttributeError", ":", "#not all elements have auth attribute..", "pass", "elif", "e", "==", "c", ".", "__class__", "or", "issubclass", "(", "c", ".", "__class__", ",", "e", ")", ":", "doignore", "=", "True", "break", "if", "doignore", ":", "continue", "if", "isinstance", "(", "c", ",", "AbstractElement", ")", ":", "j", "=", "c", ".", "getindex", "(", "child", ",", "recursive", ")", "if", "j", "!=", "-", "1", ":", "return", "i", "#yes, i ... not j!", "return", "-", "1"], "docstring_tokens": ["Get", "the", "index", "at", "which", "an", "element", "occurs", "recursive", "by", "default!"]}
{"code_tokens": ["def", "precedes", "(", "self", ",", "other", ")", ":", "try", ":", "ancestor", "=", "next", "(", "commonancestors", "(", "AbstractElement", ",", "self", ",", "other", ")", ")", "except", "StopIteration", ":", "raise", "Exception", "(", "\"Elements share no common ancestor\"", ")", "#now we just do a depth first search and see who comes first", "def", "callback", "(", "e", ")", ":", "if", "e", "is", "self", ":", "return", "True", "elif", "e", "is", "other", ":", "return", "False", "return", "None", "result", "=", "ancestor", ".", "depthfirstsearch", "(", "callback", ")", "if", "result", "is", "None", ":", "raise", "Exception", "(", "\"Unable to find relation between elements! (shouldn't happen)\"", ")", "return", "result"], "docstring_tokens": ["Returns", "a", "boolean", "indicating", "whether", "this", "element", "precedes", "the", "other", "element"]}
{"code_tokens": ["def", "depthfirstsearch", "(", "self", ",", "function", ")", ":", "result", "=", "function", "(", "self", ")", "if", "result", "is", "not", "None", ":", "return", "result", "for", "e", "in", "self", ":", "result", "=", "e", ".", "depthfirstsearch", "(", "function", ")", "if", "result", "is", "not", "None", ":", "return", "result", "return", "None"], "docstring_tokens": ["Generic", "depth", "first", "search", "algorithm", "using", "a", "callback", "function", "continues", "as", "long", "as", "the", "callback", "function", "returns", "None"]}
{"code_tokens": ["def", "next", "(", "self", ",", "Class", "=", "True", ",", "scope", "=", "True", ",", "reverse", "=", "False", ")", ":", "if", "Class", "is", "True", ":", "Class", "=", "self", ".", "__class__", "if", "scope", "is", "True", ":", "scope", "=", "STRUCTURESCOPE", "structural", "=", "Class", "is", "not", "None", "and", "issubclass", "(", "Class", ",", "AbstractStructureElement", ")", "if", "reverse", ":", "order", "=", "reversed", "descendindex", "=", "-", "1", "else", ":", "order", "=", "lambda", "x", ":", "x", "#pylint: disable=redefined-variable-type", "descendindex", "=", "0", "child", "=", "self", "parent", "=", "self", ".", "parent", "while", "parent", ":", "#pylint: disable=too-many-nested-blocks", "if", "len", "(", "parent", ")", ">", "1", ":", "returnnext", "=", "False", "for", "e", "in", "order", "(", "parent", ")", ":", "if", "e", "is", "child", ":", "#we found the current item, next item will be the one to return", "returnnext", "=", "True", "elif", "returnnext", "and", "e", ".", "auth", "and", "not", "isinstance", "(", "e", ",", "AbstractAnnotationLayer", ")", "and", "(", "not", "structural", "or", "(", "structural", "and", "(", "not", "isinstance", "(", "e", ",", "(", "AbstractTokenAnnotation", ",", "TextContent", ")", ")", ")", ")", ")", ":", "if", "structural", "and", "isinstance", "(", "e", ",", "Correction", ")", ":", "if", "not", "list", "(", "e", ".", "select", "(", "AbstractStructureElement", ")", ")", ":", "#skip-over non-structural correction", "continue", "if", "Class", "is", "None", "or", "(", "isinstance", "(", "Class", ",", "tuple", ")", "and", "(", "any", "(", "isinstance", "(", "e", ",", "C", ")", "for", "C", "in", "Class", ")", ")", ")", "or", "isinstance", "(", "e", ",", "Class", ")", ":", "return", "e", "else", ":", "#this is not yet the element of the type we are looking for, we are going to descend again in the very leftmost (rightmost if reversed) branch only", "while", "e", ".", "data", ":", "e", "=", "e", ".", "data", "[", "descendindex", "]", "if", "not", "isinstance", "(", "e", ",", "AbstractElement", ")", ":", "return", "None", "#we've gone too far", "if", "e", ".", "auth", "and", "not", "isinstance", "(", "e", ",", "AbstractAnnotationLayer", ")", ":", "if", "Class", "is", "None", "or", "(", "isinstance", "(", "Class", ",", "tuple", ")", "and", "(", "any", "(", "isinstance", "(", "e", ",", "C", ")", "for", "C", "in", "Class", ")", ")", ")", "or", "isinstance", "(", "e", ",", "Class", ")", ":", "return", "e", "else", ":", "#descend deeper", "continue", "return", "None", "#generational iteration", "child", "=", "parent", "if", "scope", "is", "not", "None", "and", "child", ".", "__class__", "in", "scope", ":", "#you shall not pass!", "break", "parent", "=", "parent", ".", "parent", "return", "None"], "docstring_tokens": ["Returns", "the", "next", "element", "if", "it", "is", "of", "the", "specified", "type", "and", "if", "it", "does", "not", "cross", "the", "boundary", "of", "the", "defined", "scope", ".", "Returns", "None", "if", "no", "next", "element", "is", "found", ".", "Non", "-", "authoritative", "elements", "are", "never", "returned", "."]}
{"code_tokens": ["def", "previous", "(", "self", ",", "Class", "=", "True", ",", "scope", "=", "True", ")", ":", "return", "self", ".", "next", "(", "Class", ",", "scope", ",", "True", ")"], "docstring_tokens": ["Returns", "the", "previous", "element", "if", "it", "is", "of", "the", "specified", "type", "and", "if", "it", "does", "not", "cross", "the", "boundary", "of", "the", "defined", "scope", ".", "Returns", "None", "if", "no", "next", "element", "is", "found", ".", "Non", "-", "authoritative", "elements", "are", "never", "returned", "."]}
{"code_tokens": ["def", "remove", "(", "self", ",", "child", ")", ":", "if", "not", "isinstance", "(", "child", ",", "AbstractElement", ")", ":", "raise", "ValueError", "(", "\"Expected AbstractElement, got \"", "+", "str", "(", "type", "(", "child", ")", ")", ")", "if", "child", ".", "parent", "==", "self", ":", "child", ".", "parent", "=", "None", "self", ".", "data", ".", "remove", "(", "child", ")", "#delete from index", "if", "child", ".", "id", "and", "self", ".", "doc", "and", "child", ".", "id", "in", "self", ".", "doc", ".", "index", ":", "del", "self", ".", "doc", ".", "index", "[", "child", ".", "id", "]"], "docstring_tokens": ["Removes", "the", "child", "element"]}
{"code_tokens": ["def", "hasannotation", "(", "self", ",", "Class", ",", "set", "=", "None", ")", ":", "return", "sum", "(", "1", "for", "_", "in", "self", ".", "select", "(", "Class", ",", "set", ",", "True", ",", "default_ignore_annotations", ")", ")"], "docstring_tokens": ["Returns", "an", "integer", "indicating", "whether", "such", "as", "annotation", "exists", "and", "if", "so", "how", "many", "."]}
{"code_tokens": ["def", "annotation", "(", "self", ",", "type", ",", "set", "=", "None", ")", ":", "\"\"\"Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found\"\"\"", "for", "e", "in", "self", ".", "select", "(", "type", ",", "set", ",", "True", ",", "default_ignore_annotations", ")", ":", "return", "e", "raise", "NoSuchAnnotation", "(", ")"], "docstring_tokens": ["Obtain", "a", "single", "annotation", "element", "."]}
{"code_tokens": ["def", "hasannotationlayer", "(", "self", ",", "annotationtype", "=", "None", ",", "set", "=", "None", ")", ":", "l", "=", "self", ".", "layers", "(", "annotationtype", ",", "set", ")", "return", "(", "len", "(", "l", ")", ">", "0", ")"], "docstring_tokens": ["Does", "the", "specified", "annotation", "layer", "exist?"]}
{"code_tokens": ["def", "getreference", "(", "self", ",", "validate", "=", "True", ")", ":", "if", "self", ".", "offset", "is", "None", ":", "return", "None", "#nothing to test", "if", "self", ".", "ref", ":", "ref", "=", "self", ".", "doc", "[", "self", ".", "ref", "]", "else", ":", "ref", "=", "self", ".", "finddefaultreference", "(", ")", "if", "not", "ref", ":", "raise", "UnresolvableTextContent", "(", "\"Default reference for textcontent not found!\"", ")", "elif", "not", "ref", ".", "hastext", "(", "self", ".", "cls", ")", ":", "raise", "UnresolvableTextContent", "(", "\"Reference (ID \"", "+", "str", "(", "ref", ".", "id", ")", "+", "\") has no such text (class=\"", "+", "self", ".", "cls", "+", "\")\"", ")", "elif", "validate", "and", "self", ".", "text", "(", ")", "!=", "ref", ".", "textcontent", "(", "self", ".", "cls", ")", ".", "text", "(", ")", "[", "self", ".", "offset", ":", "self", ".", "offset", "+", "len", "(", "self", ".", "data", "[", "0", "]", ")", "]", ":", "raise", "UnresolvableTextContent", "(", "\"Reference (ID \"", "+", "str", "(", "ref", ".", "id", ")", "+", "\", class=\"", "+", "self", ".", "cls", "+", "\") found but no text match at specified offset (\"", "+", "str", "(", "self", ".", "offset", ")", "+", "\")! Expected '\"", "+", "self", ".", "text", "(", ")", "+", "\"', got '\"", "+", "ref", ".", "textcontent", "(", "self", ".", "cls", ")", ".", "text", "(", ")", "[", "self", ".", "offset", ":", "self", ".", "offset", "+", "len", "(", "self", ".", "data", "[", "0", "]", ")", "]", "+", "\"'\"", ")", "else", ":", "#finally, we made it!", "return", "ref"], "docstring_tokens": ["Returns", "and", "validates", "the", "Text", "Content", "s", "reference", ".", "Raises", "UnresolvableTextContent", "when", "invalid"]}
{"code_tokens": ["def", "getreference", "(", "self", ",", "validate", "=", "True", ")", ":", "if", "self", ".", "offset", "is", "None", ":", "return", "None", "#nothing to test", "if", "self", ".", "ref", ":", "ref", "=", "self", ".", "doc", "[", "self", ".", "ref", "]", "else", ":", "ref", "=", "self", ".", "finddefaultreference", "(", ")", "if", "not", "ref", ":", "raise", "UnresolvableTextContent", "(", "\"Default reference for phonetic content not found!\"", ")", "elif", "not", "ref", ".", "hasphon", "(", "self", ".", "cls", ")", ":", "raise", "UnresolvableTextContent", "(", "\"Reference has no such phonetic content (class=\"", "+", "self", ".", "cls", "+", "\")\"", ")", "elif", "validate", "and", "self", ".", "phon", "(", ")", "!=", "ref", ".", "textcontent", "(", "self", ".", "cls", ")", ".", "phon", "(", ")", "[", "self", ".", "offset", ":", "self", ".", "offset", "+", "len", "(", "self", ".", "data", "[", "0", "]", ")", "]", ":", "raise", "UnresolvableTextContent", "(", "\"Reference (class=\"", "+", "self", ".", "cls", "+", "\") found but no phonetic match at specified offset (\"", "+", "str", "(", "self", ".", "offset", ")", "+", "\")! Expected '\"", "+", "self", ".", "text", "(", ")", "+", "\"', got '\"", "+", "ref", ".", "textcontent", "(", "self", ".", "cls", ")", ".", "text", "(", ")", "[", "self", ".", "offset", ":", "self", ".", "offset", "+", "len", "(", "self", ".", "data", "[", "0", "]", ")", "]", "+", "\"'\"", ")", "else", ":", "#finally, we made it!", "return", "ref"], "docstring_tokens": ["Return", "and", "validate", "the", "Phonetic", "Content", "s", "reference", ".", "Raises", "UnresolvableTextContent", "when", "invalid"]}
{"code_tokens": ["def", "findspans", "(", "self", ",", "type", ",", "set", "=", "None", ")", ":", "if", "issubclass", "(", "type", ",", "AbstractAnnotationLayer", ")", ":", "layerclass", "=", "type", "else", ":", "layerclass", "=", "ANNOTATIONTYPE2LAYERCLASS", "[", "type", ".", "ANNOTATIONTYPE", "]", "e", "=", "self", "while", "True", ":", "if", "not", "e", ".", "parent", ":", "break", "e", "=", "e", ".", "parent", "for", "layer", "in", "e", ".", "select", "(", "layerclass", ",", "set", ",", "False", ")", ":", "if", "type", "is", "layerclass", ":", "for", "e2", "in", "layer", ".", "select", "(", "AbstractSpanAnnotation", ",", "set", ",", "True", ",", "(", "True", ",", "Word", ",", "Morpheme", ")", ")", ":", "if", "not", "isinstance", "(", "e2", ",", "AbstractSpanRole", ")", "and", "self", "in", "e2", ".", "wrefs", "(", ")", ":", "yield", "e2", "else", ":", "for", "e2", "in", "layer", ".", "select", "(", "type", ",", "set", ",", "True", ",", "(", "True", ",", "Word", ",", "Morpheme", ")", ")", ":", "if", "not", "isinstance", "(", "e2", ",", "AbstractSpanRole", ")", "and", "self", "in", "e2", ".", "wrefs", "(", ")", ":", "yield", "e2"], "docstring_tokens": ["Yields", "span", "annotation", "elements", "of", "the", "specified", "type", "that", "include", "this", "word", "."]}
{"code_tokens": ["def", "setspan", "(", "self", ",", "*", "args", ")", ":", "self", ".", "data", "=", "[", "]", "for", "child", "in", "args", ":", "self", ".", "append", "(", "child", ")"], "docstring_tokens": ["Sets", "the", "span", "of", "the", "span", "element", "anew", "erases", "all", "data", "inside", "."]}
{"code_tokens": ["def", "_helper_wrefs", "(", "self", ",", "targets", ",", "recurse", "=", "True", ")", ":", "for", "c", "in", "self", ":", "if", "isinstance", "(", "c", ",", "Word", ")", "or", "isinstance", "(", "c", ",", "Morpheme", ")", "or", "isinstance", "(", "c", ",", "Phoneme", ")", ":", "targets", ".", "append", "(", "c", ")", "elif", "isinstance", "(", "c", ",", "WordReference", ")", ":", "try", ":", "targets", ".", "append", "(", "self", ".", "doc", "[", "c", ".", "id", "]", ")", "#try to resolve", "except", "KeyError", ":", "targets", ".", "append", "(", "c", ")", "#add unresolved", "elif", "isinstance", "(", "c", ",", "AbstractSpanAnnotation", ")", "and", "recurse", ":", "#recursion", "c", ".", "_helper_wrefs", "(", "targets", ")", "#pylint: disable=protected-access", "elif", "isinstance", "(", "c", ",", "Correction", ")", "and", "c", ".", "auth", ":", "#recurse into corrections", "for", "e", "in", "c", ":", "if", "isinstance", "(", "e", ",", "AbstractCorrectionChild", ")", "and", "e", ".", "auth", ":", "for", "e2", "in", "e", ":", "if", "isinstance", "(", "e2", ",", "AbstractSpanAnnotation", ")", ":", "#recursion", "e2", ".", "_helper_wrefs", "(", "targets", ")"], "docstring_tokens": ["Internal", "helper", "function"]}
{"code_tokens": ["def", "wrefs", "(", "self", ",", "index", "=", "None", ",", "recurse", "=", "True", ")", ":", "targets", "=", "[", "]", "self", ".", "_helper_wrefs", "(", "targets", ",", "recurse", ")", "if", "index", "is", "None", ":", "return", "targets", "else", ":", "return", "targets", "[", "index", "]"], "docstring_tokens": ["Returns", "a", "list", "of", "word", "references", "these", "can", "be", "Words", "but", "also", "Morphemes", "or", "Phonemes", "."]}
{"code_tokens": ["def", "copychildren", "(", "self", ",", "newdoc", "=", "None", ",", "idsuffix", "=", "\"\"", ")", ":", "if", "idsuffix", "is", "True", ":", "idsuffix", "=", "\".copy.\"", "+", "\"%08x\"", "%", "random", ".", "getrandbits", "(", "32", ")", "#random 32-bit hash for each copy, same one will be reused for all children", "for", "c", "in", "self", ":", "if", "isinstance", "(", "c", ",", "Word", ")", ":", "yield", "WordReference", "(", "newdoc", ",", "id", "=", "c", ".", "id", ")", "else", ":", "yield", "c", ".", "copy", "(", "newdoc", ",", "idsuffix", ")"], "docstring_tokens": ["Generator", "creating", "a", "deep", "copy", "of", "the", "children", "of", "this", "element", ".", "If", "idsuffix", "is", "a", "string", "if", "set", "to", "True", "a", "random", "idsuffix", "will", "be", "generated", "including", "a", "random", "32", "-", "bit", "hash"]}
{"code_tokens": ["def", "alternatives", "(", "self", ",", "Class", "=", "None", ",", "set", "=", "None", ")", ":", "for", "e", "in", "self", ".", "select", "(", "AlternativeLayers", ",", "None", ",", "True", ",", "[", "'Original'", ",", "'Suggestion'", "]", ")", ":", "#pylint: disable=too-many-nested-blocks", "if", "Class", "is", "None", ":", "yield", "e", "elif", "len", "(", "e", ")", ">=", "1", ":", "#child elements?", "for", "e2", "in", "e", ":", "try", ":", "if", "isinstance", "(", "e2", ",", "Class", ")", ":", "try", ":", "if", "set", "is", "None", "or", "e2", ".", "set", "==", "set", ":", "yield", "e", "#not e2", "break", "#yield an alternative only once (in case there are multiple matches)", "except", "AttributeError", ":", "continue", "except", "AttributeError", ":", "continue"], "docstring_tokens": ["Generator", "over", "alternatives", "either", "all", "or", "only", "of", "a", "specific", "annotation", "type", "and", "possibly", "restrained", "also", "by", "set", "."]}
{"code_tokens": ["def", "findspan", "(", "self", ",", "*", "words", ")", ":", "for", "span", "in", "self", ".", "select", "(", "AbstractSpanAnnotation", ",", "None", ",", "True", ")", ":", "if", "tuple", "(", "span", ".", "wrefs", "(", ")", ")", "==", "words", ":", "return", "span", "raise", "NoSuchAnnotation"], "docstring_tokens": ["Returns", "the", "span", "element", "which", "spans", "over", "the", "specified", "words", "or", "morphemes", "."]}
{"code_tokens": ["def", "hasnew", "(", "self", ",", "allowempty", "=", "False", ")", ":", "for", "e", "in", "self", ".", "select", "(", "New", ",", "None", ",", "False", ",", "False", ")", ":", "if", "not", "allowempty", "and", "len", "(", "e", ")", "==", "0", ":", "continue", "return", "True", "return", "False"], "docstring_tokens": ["Does", "the", "correction", "define", "new", "corrected", "annotations?"]}
{"code_tokens": ["def", "hasoriginal", "(", "self", ",", "allowempty", "=", "False", ")", ":", "for", "e", "in", "self", ".", "select", "(", "Original", ",", "None", ",", "False", ",", "False", ")", ":", "if", "not", "allowempty", "and", "len", "(", "e", ")", "==", "0", ":", "continue", "return", "True", "return", "False"], "docstring_tokens": ["Does", "the", "correction", "record", "the", "old", "annotations", "prior", "to", "correction?"]}
{"code_tokens": ["def", "hassuggestions", "(", "self", ",", "allowempty", "=", "False", ")", ":", "for", "e", "in", "self", ".", "select", "(", "Suggestion", ",", "None", ",", "False", ",", "False", ")", ":", "if", "not", "allowempty", "and", "len", "(", "e", ")", "==", "0", ":", "continue", "return", "True", "return", "False"], "docstring_tokens": ["Does", "the", "correction", "propose", "suggestions", "for", "correction?"]}
{"code_tokens": ["def", "new", "(", "self", ",", "index", "=", "None", ")", ":", "if", "index", "is", "None", ":", "try", ":", "return", "next", "(", "self", ".", "select", "(", "New", ",", "None", ",", "False", ")", ")", "except", "StopIteration", ":", "raise", "NoSuchAnnotation", "else", ":", "for", "e", "in", "self", ".", "select", "(", "New", ",", "None", ",", "False", ")", ":", "return", "e", "[", "index", "]", "raise", "NoSuchAnnotation"], "docstring_tokens": ["Get", "the", "new", "corrected", "annotation", "."]}
{"code_tokens": ["def", "original", "(", "self", ",", "index", "=", "None", ")", ":", "if", "index", "is", "None", ":", "try", ":", "return", "next", "(", "self", ".", "select", "(", "Original", ",", "None", ",", "False", ",", "False", ")", ")", "except", "StopIteration", ":", "raise", "NoSuchAnnotation", "else", ":", "for", "e", "in", "self", ".", "select", "(", "Original", ",", "None", ",", "False", ",", "False", ")", ":", "return", "e", "[", "index", "]", "raise", "NoSuchAnnotation"], "docstring_tokens": ["Get", "the", "old", "annotation", "prior", "to", "correction", "."]}
{"code_tokens": ["def", "suggestions", "(", "self", ",", "index", "=", "None", ")", ":", "if", "index", "is", "None", ":", "return", "self", ".", "select", "(", "Suggestion", ",", "None", ",", "False", ",", "False", ")", "else", ":", "for", "i", ",", "e", "in", "enumerate", "(", "self", ".", "select", "(", "Suggestion", ",", "None", ",", "False", ",", "False", ")", ")", ":", "if", "index", "==", "i", ":", "return", "e", "raise", "IndexError"], "docstring_tokens": ["Get", "suggestions", "for", "correction", "."]}
{"code_tokens": ["def", "findspans", "(", "self", ",", "type", ",", "set", "=", "None", ")", ":", "if", "issubclass", "(", "type", ",", "AbstractAnnotationLayer", ")", ":", "layerclass", "=", "type", "else", ":", "layerclass", "=", "ANNOTATIONTYPE2LAYERCLASS", "[", "type", ".", "ANNOTATIONTYPE", "]", "e", "=", "self", "while", "True", ":", "if", "not", "e", ".", "parent", ":", "break", "e", "=", "e", ".", "parent", "for", "layer", "in", "e", ".", "select", "(", "layerclass", ",", "set", ",", "False", ")", ":", "for", "e2", "in", "layer", ":", "if", "isinstance", "(", "e2", ",", "AbstractSpanAnnotation", ")", ":", "if", "self", "in", "e2", ".", "wrefs", "(", ")", ":", "yield", "e2"], "docstring_tokens": ["Find", "span", "annotation", "of", "the", "specified", "type", "that", "include", "this", "word"]}
{"code_tokens": ["def", "resolve", "(", "self", ",", "size", ",", "distribution", ")", ":", "if", "not", "self", ".", "variablesize", "(", ")", ":", "raise", "Exception", "(", "\"Can only resize patterns with * wildcards\"", ")", "nrofwildcards", "=", "0", "for", "x", "in", "self", ".", "sequence", ":", "if", "x", "==", "'*'", ":", "nrofwildcards", "+=", "1", "assert", "(", "len", "(", "distribution", ")", "==", "nrofwildcards", ")", "wildcardnr", "=", "0", "newsequence", "=", "[", "]", "for", "x", "in", "self", ".", "sequence", ":", "if", "x", "==", "'*'", ":", "newsequence", "+=", "[", "True", "]", "*", "distribution", "[", "wildcardnr", "]", "wildcardnr", "+=", "1", "else", ":", "newsequence", ".", "append", "(", "x", ")", "d", "=", "{", "'matchannotation'", ":", "self", ".", "matchannotation", ",", "'matchannotationset'", ":", "self", ".", "matchannotationset", ",", "'casesensitive'", ":", "self", ".", "casesensitive", "}", "yield", "Pattern", "(", "*", "newsequence", ",", "*", "*", "d", ")"], "docstring_tokens": ["Resolve", "a", "variable", "sized", "pattern", "to", "all", "patterns", "of", "a", "certain", "fixed", "size"]}
{"code_tokens": ["def", "load", "(", "self", ",", "filename", ")", ":", "#if LXE and self.mode != Mode.XPATH:", "#    #workaround for xml:id problem (disabled)", "#    #f = open(filename)", "#    #s = f.read().replace(' xml:id=', ' id=')", "#    #f.close()", "#    self.tree = ElementTree.parse(filename)", "#else:", "self", ".", "tree", "=", "xmltreefromfile", "(", "filename", ")", "self", ".", "parsexml", "(", "self", ".", "tree", ".", "getroot", "(", ")", ")", "if", "self", ".", "mode", "!=", "Mode", ".", "XPATH", ":", "#XML Tree is now obsolete (only needed when partially loaded for xpath queries)", "self", ".", "tree", "=", "None"], "docstring_tokens": ["Load", "a", "FoLiA", "XML", "file", "."]}
{"code_tokens": ["def", "items", "(", "self", ")", ":", "l", "=", "[", "]", "for", "e", "in", "self", ".", "data", ":", "l", "+=", "e", ".", "items", "(", ")", "return", "l"], "docstring_tokens": ["Returns", "a", "depth", "-", "first", "flat", "list", "of", "all", "items", "in", "the", "document"]}
{"code_tokens": ["def", "save", "(", "self", ",", "filename", "=", "None", ")", ":", "if", "not", "filename", ":", "filename", "=", "self", ".", "filename", "if", "not", "filename", ":", "raise", "Exception", "(", "\"No filename specified\"", ")", "if", "filename", "[", "-", "4", ":", "]", ".", "lower", "(", ")", "==", "'.bz2'", ":", "f", "=", "bz2", ".", "BZ2File", "(", "filename", ",", "'wb'", ")", "f", ".", "write", "(", "self", ".", "xmlstring", "(", ")", ".", "encode", "(", "'utf-8'", ")", ")", "f", ".", "close", "(", ")", "elif", "filename", "[", "-", "3", ":", "]", ".", "lower", "(", ")", "==", "'.gz'", ":", "f", "=", "gzip", ".", "GzipFile", "(", "filename", ",", "'wb'", ")", "#pylint: disable=redefined-variable-type", "f", ".", "write", "(", "self", ".", "xmlstring", "(", ")", ".", "encode", "(", "'utf-8'", ")", ")", "f", ".", "close", "(", ")", "else", ":", "f", "=", "io", ".", "open", "(", "filename", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "f", ".", "write", "(", "self", ".", "xmlstring", "(", ")", ")", "f", ".", "close", "(", ")"], "docstring_tokens": ["Save", "the", "document", "to", "file", "."]}
{"code_tokens": ["def", "xmldeclarations", "(", "self", ")", ":", "l", "=", "[", "]", "E", "=", "ElementMaker", "(", "namespace", "=", "\"http://ilk.uvt.nl/folia\"", ",", "nsmap", "=", "{", "None", ":", "\"http://ilk.uvt.nl/folia\"", ",", "'xml'", ":", "\"http://www.w3.org/XML/1998/namespace\"", "}", ")", "for", "annotationtype", ",", "set", "in", "self", ".", "annotations", ":", "label", "=", "None", "#Find the 'label' for the declarations dynamically (aka: AnnotationType --> String)", "for", "key", ",", "value", "in", "vars", "(", "AnnotationType", ")", ".", "items", "(", ")", ":", "if", "value", "==", "annotationtype", ":", "label", "=", "key", "break", "#gather attribs", "if", "(", "annotationtype", "==", "AnnotationType", ".", "TEXT", "or", "annotationtype", "==", "AnnotationType", ".", "PHON", ")", "and", "set", "==", "'undefined'", "and", "len", "(", "self", ".", "annotationdefaults", "[", "annotationtype", "]", "[", "set", "]", ")", "==", "0", ":", "#this is the implicit TextContent declaration, no need to output it explicitly", "continue", "attribs", "=", "{", "}", "if", "set", "and", "set", "!=", "'undefined'", ":", "attribs", "[", "'{'", "+", "NSFOLIA", "+", "'}set'", "]", "=", "set", "for", "key", ",", "value", "in", "self", ".", "annotationdefaults", "[", "annotationtype", "]", "[", "set", "]", ".", "items", "(", ")", ":", "if", "key", "==", "'annotatortype'", ":", "if", "value", "==", "AnnotatorType", ".", "MANUAL", ":", "attribs", "[", "'{'", "+", "NSFOLIA", "+", "'}'", "+", "key", "]", "=", "'manual'", "elif", "value", "==", "AnnotatorType", ".", "AUTO", ":", "attribs", "[", "'{'", "+", "NSFOLIA", "+", "'}'", "+", "key", "]", "=", "'auto'", "elif", "key", "==", "'datetime'", ":", "attribs", "[", "'{'", "+", "NSFOLIA", "+", "'}'", "+", "key", "]", "=", "value", ".", "strftime", "(", "\"%Y-%m-%dT%H:%M:%S\"", ")", "#proper iso-formatting", "elif", "value", ":", "attribs", "[", "'{'", "+", "NSFOLIA", "+", "'}'", "+", "key", "]", "=", "value", "if", "label", ":", "l", ".", "append", "(", "makeelement", "(", "E", ",", "'{'", "+", "NSFOLIA", "+", "'}'", "+", "label", ".", "lower", "(", ")", "+", "'-annotation'", ",", "*", "*", "attribs", ")", ")", "else", ":", "raise", "Exception", "(", "\"Invalid annotation type\"", ")", "return", "l"], "docstring_tokens": ["Internal", "method", "to", "generate", "XML", "nodes", "for", "all", "declarations"]}
{"code_tokens": ["def", "jsondeclarations", "(", "self", ")", ":", "l", "=", "[", "]", "for", "annotationtype", ",", "set", "in", "self", ".", "annotations", ":", "label", "=", "None", "#Find the 'label' for the declarations dynamically (aka: AnnotationType --> String)", "for", "key", ",", "value", "in", "vars", "(", "AnnotationType", ")", ".", "items", "(", ")", ":", "if", "value", "==", "annotationtype", ":", "label", "=", "key", "break", "#gather attribs", "if", "(", "annotationtype", "==", "AnnotationType", ".", "TEXT", "or", "annotationtype", "==", "AnnotationType", ".", "PHON", ")", "and", "set", "==", "'undefined'", "and", "len", "(", "self", ".", "annotationdefaults", "[", "annotationtype", "]", "[", "set", "]", ")", "==", "0", ":", "#this is the implicit TextContent declaration, no need to output it explicitly", "continue", "jsonnode", "=", "{", "'annotationtype'", ":", "label", ".", "lower", "(", ")", "}", "if", "set", "and", "set", "!=", "'undefined'", ":", "jsonnode", "[", "'set'", "]", "=", "set", "for", "key", ",", "value", "in", "self", ".", "annotationdefaults", "[", "annotationtype", "]", "[", "set", "]", ".", "items", "(", ")", ":", "if", "key", "==", "'annotatortype'", ":", "if", "value", "==", "AnnotatorType", ".", "MANUAL", ":", "jsonnode", "[", "key", "]", "=", "'manual'", "elif", "value", "==", "AnnotatorType", ".", "AUTO", ":", "jsonnode", "[", "key", "]", "=", "'auto'", "elif", "key", "==", "'datetime'", ":", "jsonnode", "[", "key", "]", "=", "value", ".", "strftime", "(", "\"%Y-%m-%dT%H:%M:%S\"", ")", "#proper iso-formatting", "elif", "value", ":", "jsonnode", "[", "key", "]", "=", "value", "if", "label", ":", "l", ".", "append", "(", "jsonnode", ")", "else", ":", "raise", "Exception", "(", "\"Invalid annotation type\"", ")", "return", "l"], "docstring_tokens": ["Return", "all", "declarations", "in", "a", "form", "ready", "to", "be", "serialised", "to", "JSON", "."]}
{"code_tokens": ["def", "xml", "(", "self", ")", ":", "self", ".", "pendingvalidation", "(", ")", "E", "=", "ElementMaker", "(", "namespace", "=", "\"http://ilk.uvt.nl/folia\"", ",", "nsmap", "=", "{", "'xml'", ":", "\"http://www.w3.org/XML/1998/namespace\"", ",", "'xlink'", ":", "\"http://www.w3.org/1999/xlink\"", "}", ")", "attribs", "=", "{", "}", "attribs", "[", "'{http://www.w3.org/XML/1998/namespace}id'", "]", "=", "self", ".", "id", "#if self.version:", "#    attribs['version'] = self.version", "#else:", "attribs", "[", "'version'", "]", "=", "FOLIAVERSION", "attribs", "[", "'generator'", "]", "=", "'pynlpl.formats.folia-v'", "+", "LIBVERSION", "metadataattribs", "=", "{", "}", "metadataattribs", "[", "'{'", "+", "NSFOLIA", "+", "'}type'", "]", "=", "self", ".", "metadatatype", "if", "isinstance", "(", "self", ".", "metadata", ",", "ExternalMetaData", ")", ":", "metadataattribs", "[", "'{'", "+", "NSFOLIA", "+", "'}src'", "]", "=", "self", ".", "metadata", ".", "url", "e", "=", "E", ".", "FoLiA", "(", "E", ".", "metadata", "(", "E", ".", "annotations", "(", "*", "self", ".", "xmldeclarations", "(", ")", ")", ",", "*", "self", ".", "xmlmetadata", "(", ")", ",", "*", "*", "metadataattribs", ")", ",", "*", "*", "attribs", ")", "for", "text", "in", "self", ".", "data", ":", "e", ".", "append", "(", "text", ".", "xml", "(", ")", ")", "return", "e"], "docstring_tokens": ["Serialise", "the", "document", "to", "XML", "."]}
{"code_tokens": ["def", "json", "(", "self", ")", ":", "self", ".", "pendingvalidation", "(", ")", "jsondoc", "=", "{", "'id'", ":", "self", ".", "id", ",", "'children'", ":", "[", "]", ",", "'declarations'", ":", "self", ".", "jsondeclarations", "(", ")", "}", "if", "self", ".", "version", ":", "jsondoc", "[", "'version'", "]", "=", "self", ".", "version", "else", ":", "jsondoc", "[", "'version'", "]", "=", "FOLIAVERSION", "jsondoc", "[", "'generator'", "]", "=", "'pynlpl.formats.folia-v'", "+", "LIBVERSION", "for", "text", "in", "self", ".", "data", ":", "jsondoc", "[", "'children'", "]", ".", "append", "(", "text", ".", "json", "(", ")", ")", "return", "jsondoc"], "docstring_tokens": ["Serialise", "the", "document", "to", "a", "dict", "ready", "for", "serialisation", "to", "JSON", "."]}
{"code_tokens": ["def", "xmlmetadata", "(", "self", ")", ":", "E", "=", "ElementMaker", "(", "namespace", "=", "\"http://ilk.uvt.nl/folia\"", ",", "nsmap", "=", "{", "None", ":", "\"http://ilk.uvt.nl/folia\"", ",", "'xml'", ":", "\"http://www.w3.org/XML/1998/namespace\"", "}", ")", "elements", "=", "[", "]", "if", "self", ".", "metadatatype", "==", "\"native\"", ":", "if", "isinstance", "(", "self", ".", "metadata", ",", "NativeMetaData", ")", ":", "for", "key", ",", "value", "in", "self", ".", "metadata", ".", "items", "(", ")", ":", "elements", ".", "append", "(", "E", ".", "meta", "(", "value", ",", "id", "=", "key", ")", ")", "else", ":", "if", "isinstance", "(", "self", ".", "metadata", ",", "ForeignData", ")", ":", "#in-document", "m", "=", "self", ".", "metadata", "while", "m", "is", "not", "None", ":", "elements", ".", "append", "(", "m", ".", "xml", "(", ")", ")", "m", "=", "m", ".", "next", "for", "metadata_id", ",", "submetadata", "in", "self", ".", "submetadata", ".", "items", "(", ")", ":", "subelements", "=", "[", "]", "attribs", "=", "{", "\"{http://www.w3.org/XML/1998/namespace}id\"", ":", "metadata_id", ",", "\"type\"", ":", "self", ".", "submetadatatype", "[", "metadata_id", "]", "}", "if", "isinstance", "(", "submetadata", ",", "NativeMetaData", ")", ":", "for", "key", ",", "value", "in", "submetadata", ".", "items", "(", ")", ":", "subelements", ".", "append", "(", "E", ".", "meta", "(", "value", ",", "id", "=", "key", ")", ")", "elif", "isinstance", "(", "submetadata", ",", "ExternalMetaData", ")", ":", "attribs", "[", "'src'", "]", "=", "submetadata", ".", "url", "elif", "isinstance", "(", "submetadata", ",", "ForeignData", ")", ":", "#in-document", "m", "=", "submetadata", "while", "m", "is", "not", "None", ":", "subelements", ".", "append", "(", "m", ".", "xml", "(", ")", ")", "m", "=", "m", ".", "next", "elements", ".", "append", "(", "E", ".", "submetadata", "(", "*", "subelements", ",", "*", "*", "attribs", ")", ")", "return", "elements"], "docstring_tokens": ["Internal", "method", "to", "serialize", "metadata", "to", "XML"]}
{"code_tokens": ["def", "declare", "(", "self", ",", "annotationtype", ",", "set", ",", "*", "*", "kwargs", ")", ":", "if", "(", "sys", ".", "version", ">", "'3'", "and", "not", "isinstance", "(", "set", ",", "str", ")", ")", "or", "(", "sys", ".", "version", "<", "'3'", "and", "not", "isinstance", "(", "set", ",", "(", "str", ",", "unicode", ")", ")", ")", ":", "raise", "ValueError", "(", "\"Set parameter for declare() must be a string\"", ")", "if", "inspect", ".", "isclass", "(", "annotationtype", ")", ":", "annotationtype", "=", "annotationtype", ".", "ANNOTATIONTYPE", "if", "annotationtype", "in", "self", ".", "alias_set", "and", "set", "in", "self", ".", "alias_set", "[", "annotationtype", "]", ":", "raise", "ValueError", "(", "\"Set \"", "+", "set", "+", "\" conflicts with alias, may not be equal!\"", ")", "if", "not", "(", "annotationtype", ",", "set", ")", "in", "self", ".", "annotations", ":", "self", ".", "annotations", ".", "append", "(", "(", "annotationtype", ",", "set", ")", ")", "if", "set", "and", "self", ".", "loadsetdefinitions", "and", "not", "set", "in", "self", ".", "setdefinitions", ":", "if", "set", "[", ":", "7", "]", "==", "\"http://\"", "or", "set", "[", ":", "8", "]", "==", "\"https://\"", "or", "set", "[", ":", "6", "]", "==", "\"ftp://\"", ":", "self", ".", "setdefinitions", "[", "set", "]", "=", "SetDefinition", "(", "set", ",", "verbose", "=", "self", ".", "verbose", ")", "#will raise exception on error", "if", "not", "annotationtype", "in", "self", ".", "annotationdefaults", ":", "self", ".", "annotationdefaults", "[", "annotationtype", "]", "=", "{", "}", "self", ".", "annotationdefaults", "[", "annotationtype", "]", "[", "set", "]", "=", "kwargs", "if", "'alias'", "in", "kwargs", ":", "if", "annotationtype", "in", "self", ".", "set_alias", "and", "set", "in", "self", ".", "set_alias", "[", "annotationtype", "]", "and", "self", ".", "set_alias", "[", "annotationtype", "]", "[", "set", "]", "!=", "kwargs", "[", "'alias'", "]", ":", "raise", "ValueError", "(", "\"Redeclaring set \"", "+", "set", "+", "\" with another alias ('\"", "+", "kwargs", "[", "'alias'", "]", "+", "\"') is not allowed!\"", ")", "if", "annotationtype", "in", "self", ".", "alias_set", "and", "kwargs", "[", "'alias'", "]", "in", "self", ".", "alias_set", "[", "annotationtype", "]", "and", "self", ".", "alias_set", "[", "annotationtype", "]", "[", "kwargs", "[", "'alias'", "]", "]", "!=", "set", ":", "raise", "ValueError", "(", "\"Redeclaring alias \"", "+", "kwargs", "[", "'alias'", "]", "+", "\" with another set ('\"", "+", "set", "+", "\"') is not allowed!\"", ")", "if", "annotationtype", "in", "self", ".", "set_alias", "and", "kwargs", "[", "'alias'", "]", "in", "self", ".", "set_alias", "[", "annotationtype", "]", ":", "raise", "ValueError", "(", "\"Alias \"", "+", "kwargs", "[", "'alias'", "]", "+", "\" conflicts with set name, may not be equal!\"", ")", "if", "annotationtype", "not", "in", "self", ".", "alias_set", ":", "self", ".", "alias_set", "[", "annotationtype", "]", "=", "{", "}", "if", "annotationtype", "not", "in", "self", ".", "set_alias", ":", "self", ".", "set_alias", "[", "annotationtype", "]", "=", "{", "}", "self", ".", "alias_set", "[", "annotationtype", "]", "[", "kwargs", "[", "'alias'", "]", "]", "=", "set", "self", ".", "set_alias", "[", "annotationtype", "]", "[", "set", "]", "=", "kwargs", "[", "'alias'", "]"], "docstring_tokens": ["Declare", "a", "new", "annotation", "type", "to", "be", "used", "in", "the", "document", "."]}
{"code_tokens": ["def", "defaultset", "(", "self", ",", "annotationtype", ")", ":", "if", "inspect", ".", "isclass", "(", "annotationtype", ")", "or", "isinstance", "(", "annotationtype", ",", "AbstractElement", ")", ":", "annotationtype", "=", "annotationtype", ".", "ANNOTATIONTYPE", "try", ":", "return", "list", "(", "self", ".", "annotationdefaults", "[", "annotationtype", "]", ".", "keys", "(", ")", ")", "[", "0", "]", "except", "KeyError", ":", "raise", "NoDefaultError", "except", "IndexError", ":", "raise", "NoDefaultError"], "docstring_tokens": ["Obtain", "the", "default", "set", "for", "the", "specified", "annotation", "type", "."]}
{"code_tokens": ["def", "defaultannotator", "(", "self", ",", "annotationtype", ",", "set", "=", "None", ")", ":", "if", "inspect", ".", "isclass", "(", "annotationtype", ")", "or", "isinstance", "(", "annotationtype", ",", "AbstractElement", ")", ":", "annotationtype", "=", "annotationtype", ".", "ANNOTATIONTYPE", "if", "not", "set", ":", "set", "=", "self", ".", "defaultset", "(", "annotationtype", ")", "try", ":", "return", "self", ".", "annotationdefaults", "[", "annotationtype", "]", "[", "set", "]", "[", "'annotator'", "]", "except", "KeyError", ":", "raise", "NoDefaultError"], "docstring_tokens": ["Obtain", "the", "default", "annotator", "for", "the", "specified", "annotation", "type", "and", "set", "."]}
{"code_tokens": ["def", "parsemetadata", "(", "self", ",", "node", ")", ":", "if", "'type'", "in", "node", ".", "attrib", ":", "self", ".", "metadatatype", "=", "node", ".", "attrib", "[", "'type'", "]", "else", ":", "#no type specified, default to native", "self", ".", "metadatatype", "=", "\"native\"", "if", "'src'", "in", "node", ".", "attrib", ":", "self", ".", "metadata", "=", "ExternalMetaData", "(", "node", ".", "attrib", "[", "'src'", "]", ")", "elif", "self", ".", "metadatatype", "==", "\"native\"", ":", "self", ".", "metadata", "=", "NativeMetaData", "(", ")", "else", ":", "self", ".", "metadata", "=", "None", "#may be set below to ForeignData", "for", "subnode", "in", "node", ":", "if", "subnode", ".", "tag", "==", "'{'", "+", "NSFOLIA", "+", "'}annotations'", ":", "self", ".", "parsexmldeclarations", "(", "subnode", ")", "elif", "subnode", ".", "tag", "==", "'{'", "+", "NSFOLIA", "+", "'}meta'", ":", "if", "self", ".", "metadatatype", "==", "\"native\"", ":", "if", "subnode", ".", "text", ":", "self", ".", "metadata", "[", "subnode", ".", "attrib", "[", "'id'", "]", "]", "=", "subnode", ".", "text", "else", ":", "raise", "MetaDataError", "(", "\"Encountered a meta element but metadata type is not native!\"", ")", "elif", "subnode", ".", "tag", "==", "'{'", "+", "NSFOLIA", "+", "'}provenance'", ":", "#forward compatibility with FoLiA 2.0; ignore provenance", "print", "(", "\"WARNING: Ignoring provenance data. Use foliapy instead of pynlpl.formats.folia for FoLiA v2.0 compatibility!\"", ",", "file", "=", "sys", ".", "stderr", ")", "pass", "elif", "subnode", ".", "tag", "==", "'{'", "+", "NSFOLIA", "+", "'}foreign-data'", ":", "if", "self", ".", "metadatatype", "==", "\"native\"", ":", "raise", "MetaDataError", "(", "\"Encountered a foreign-data element but metadata type is native!\"", ")", "elif", "self", ".", "metadata", "is", "not", "None", ":", "#multiple foreign-data elements, chain:", "e", "=", "self", ".", "metadata", "while", "e", ".", "next", "is", "not", "None", ":", "e", "=", "e", ".", "next", "e", ".", "next", "=", "ForeignData", "(", "self", ",", "node", "=", "subnode", ")", "else", ":", "self", ".", "metadata", "=", "ForeignData", "(", "self", ",", "node", "=", "subnode", ")", "elif", "subnode", ".", "tag", "==", "'{'", "+", "NSFOLIA", "+", "'}submetadata'", ":", "self", ".", "parsesubmetadata", "(", "subnode", ")", "elif", "subnode", ".", "tag", "==", "'{http://www.mpi.nl/IMDI/Schema/IMDI}METATRANSCRIPT'", ":", "#backward-compatibility for old IMDI without foreign-key", "E", "=", "ElementMaker", "(", "namespace", "=", "NSFOLIA", ",", "nsmap", "=", "{", "None", ":", "NSFOLIA", ",", "'xml'", ":", "\"http://www.w3.org/XML/1998/namespace\"", "}", ")", "self", ".", "metadatatype", "=", "\"imdi\"", "self", ".", "metadata", "=", "ForeignData", "(", "self", ",", "node", "=", "subnode", ")"], "docstring_tokens": ["Internal", "method", "to", "parse", "metadata"]}
{"code_tokens": ["def", "pendingvalidation", "(", "self", ",", "warnonly", "=", "None", ")", ":", "if", "self", ".", "debug", ":", "print", "(", "\"[PyNLPl FoLiA DEBUG] Processing pending validations (if any)\"", ",", "file", "=", "stderr", ")", "if", "warnonly", "is", "None", "and", "self", "and", "self", ".", "version", ":", "warnonly", "=", "(", "checkversion", "(", "self", ".", "version", ",", "'1.5.0'", ")", "<", "0", ")", "#warn only for documents older than FoLiA v1.5", "if", "self", ".", "textvalidation", ":", "while", "self", ".", "offsetvalidationbuffer", ":", "structureelement", ",", "textclass", "=", "self", ".", "offsetvalidationbuffer", ".", "pop", "(", ")", "if", "self", ".", "debug", ":", "print", "(", "\"[PyNLPl FoLiA DEBUG] Performing offset validation on \"", "+", "repr", "(", "structureelement", ")", "+", "\" textclass \"", "+", "textclass", ",", "file", "=", "stderr", ")", "#validate offsets", "tc", "=", "structureelement", ".", "textcontent", "(", "textclass", ")", "if", "tc", ".", "offset", "is", "not", "None", ":", "try", ":", "tc", ".", "getreference", "(", "validate", "=", "True", ")", "except", "UnresolvableTextContent", ":", "msg", "=", "\"Text for \"", "+", "structureelement", ".", "__class__", ".", "__name__", "+", "\", ID \"", "+", "str", "(", "structureelement", ".", "id", ")", "+", "\", textclass \"", "+", "textclass", "+", "\", has incorrect offset \"", "+", "str", "(", "tc", ".", "offset", ")", "+", "\" or invalid reference\"", "print", "(", "\"TEXT VALIDATION ERROR: \"", "+", "msg", ",", "file", "=", "sys", ".", "stderr", ")", "if", "not", "warnonly", ":", "raise"], "docstring_tokens": ["Perform", "any", "pending", "validations"]}
{"code_tokens": ["def", "paragraphs", "(", "self", ",", "index", "=", "None", ")", ":", "if", "index", "is", "None", ":", "return", "self", ".", "select", "(", "Paragraph", ")", "else", ":", "if", "index", "<", "0", ":", "index", "=", "sum", "(", "t", ".", "count", "(", "Paragraph", ")", "for", "t", "in", "self", ".", "data", ")", "+", "index", "for", "t", "in", "self", ".", "data", ":", "for", "i", ",", "e", "in", "enumerate", "(", "t", ".", "select", "(", "Paragraph", ")", ")", ":", "if", "i", "==", "index", ":", "return", "e", "raise", "IndexError"], "docstring_tokens": ["Return", "a", "generator", "of", "all", "paragraphs", "found", "in", "the", "document", "."]}
{"code_tokens": ["def", "sentences", "(", "self", ",", "index", "=", "None", ")", ":", "if", "index", "is", "None", ":", "return", "self", ".", "select", "(", "Sentence", ",", "None", ",", "True", ",", "[", "Quote", "]", ")", "else", ":", "if", "index", "<", "0", ":", "index", "=", "sum", "(", "t", ".", "count", "(", "Sentence", ",", "None", ",", "True", ",", "[", "Quote", "]", ")", "for", "t", "in", "self", ".", "data", ")", "+", "index", "for", "t", "in", "self", ".", "data", ":", "for", "i", ",", "e", "in", "enumerate", "(", "t", ".", "select", "(", "Sentence", ",", "None", ",", "True", ",", "[", "Quote", "]", ")", ")", ":", "if", "i", "==", "index", ":", "return", "e", "raise", "IndexError"], "docstring_tokens": ["Return", "a", "generator", "of", "all", "sentence", "found", "in", "the", "document", ".", "Except", "for", "sentences", "in", "quotes", "."]}
{"code_tokens": ["def", "_states", "(", "self", ",", "state", ",", "processedstates", "=", "[", "]", ")", ":", "#pylint: disable=dangerous-default-value", "processedstates", ".", "append", "(", "state", ")", "for", "nextstate", "in", "state", ".", "epsilon", ":", "if", "not", "nextstate", "in", "processedstates", ":", "self", ".", "_states", "(", "nextstate", ",", "processedstates", ")", "for", "_", ",", "nextstate", "in", "state", ".", "transitions", ":", "if", "not", "nextstate", "in", "processedstates", ":", "self", ".", "_states", "(", "nextstate", ",", "processedstates", ")", "return", "processedstates"], "docstring_tokens": ["Iterate", "over", "all", "states", "in", "no", "particular", "order"]}
{"code_tokens": ["def", "log", "(", "msg", ",", "*", "*", "kwargs", ")", ":", "if", "'debug'", "in", "kwargs", ":", "if", "'currentdebug'", "in", "kwargs", ":", "if", "kwargs", "[", "'currentdebug'", "]", "<", "kwargs", "[", "'debug'", "]", ":", "return", "False", "else", ":", "return", "False", "#no currentdebug passed, assuming no debug mode and thus skipping message", "s", "=", "\"[\"", "+", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%Y-%m-%d %H:%M:%S\"", ")", "+", "\"] \"", "if", "'system'", "in", "kwargs", ":", "s", "+=", "\"[\"", "+", "system", "+", "\"] \"", "if", "'indent'", "in", "kwargs", ":", "s", "+=", "(", "\"\\t\"", "*", "int", "(", "kwargs", "[", "'indent'", "]", ")", ")", "s", "+=", "u", "(", "msg", ")", "if", "s", "[", "-", "1", "]", "!=", "'\\n'", ":", "s", "+=", "'\\n'", "if", "'streams'", "in", "kwargs", ":", "streams", "=", "kwargs", "[", "'streams'", "]", "elif", "'stream'", "in", "kwargs", ":", "streams", "=", "[", "kwargs", "[", "'stream'", "]", "]", "else", ":", "streams", "=", "[", "stderr", "]", "for", "stream", "in", "streams", ":", "stream", ".", "write", "(", "s", ")", "return", "s"], "docstring_tokens": ["Generic", "log", "method", ".", "Will", "prepend", "timestamp", "."]}
{"code_tokens": ["def", "get_syn_ids_by_lemma", "(", "self", ",", "lemma", ")", ":", "if", "not", "isinstance", "(", "lemma", ",", "unicode", ")", ":", "lemma", "=", "unicode", "(", "lemma", ",", "'utf-8'", ")", "http", ",", "resp", ",", "content", "=", "self", ".", "connect", "(", ")", "params", "=", "\"\"", "fragment", "=", "\"\"", "path", "=", "\"cdb_syn\"", "if", "self", ".", "debug", ":", "printf", "(", "\"cornettodb/views/query_remote_syn_lemma: db_opt: %s\"", "%", "path", ")", "query_opt", "=", "\"dict_search\"", "if", "self", ".", "debug", ":", "printf", "(", "\"cornettodb/views/query_remote_syn_lemma: query_opt: %s\"", "%", "query_opt", ")", "qdict", "=", "{", "}", "qdict", "[", "\"action\"", "]", "=", "\"queryList\"", "qdict", "[", "\"word\"", "]", "=", "lemma", ".", "encode", "(", "'utf-8'", ")", "query", "=", "urllib", ".", "urlencode", "(", "qdict", ")", "db_url_tuple", "=", "(", "self", ".", "scheme", ",", "self", ".", "host", "+", "':'", "+", "str", "(", "self", ".", "port", ")", ",", "path", ",", "params", ",", "query", ",", "fragment", ")", "db_url", "=", "urlparse", ".", "urlunparse", "(", "db_url_tuple", ")", "if", "self", ".", "debug", ":", "printf", "(", "\"db_url: %s\"", "%", "db_url", ")", "resp", ",", "content", "=", "http", ".", "request", "(", "db_url", ",", "\"GET\"", ")", "if", "self", ".", "debug", ":", "printf", "(", "\"resp:\\n%s\"", "%", "resp", ")", "printf", "(", "\"content:\\n%s\"", "%", "content", ")", "#    printf( \"content is of type: %s\" % type( content ) )", "dict_list", "=", "[", "]", "dict_list", "=", "eval", "(", "content", ")", "# string to list", "synsets", "=", "[", "]", "items", "=", "len", "(", "dict_list", ")", "if", "self", ".", "debug", ":", "printf", "(", "\"items: %d\"", "%", "items", ")", "# syn dict: like lu dict, but without pos: part-of-speech", "for", "dict", "in", "dict_list", ":", "if", "self", ".", "debug", ":", "printf", "(", "dict", ")", "seq_nr", "=", "dict", "[", "\"seq_nr\"", "]", "# sense number", "value", "=", "dict", "[", "\"value\"", "]", "# lexical unit identifier", "form", "=", "dict", "[", "\"form\"", "]", "# lemma", "label", "=", "dict", "[", "\"label\"", "]", "# label to be shown", "if", "self", ".", "debug", ":", "printf", "(", "\"seq_nr: %s\"", "%", "seq_nr", ")", "printf", "(", "\"value:  %s\"", "%", "value", ")", "printf", "(", "\"form:   %s\"", "%", "form", ")", "printf", "(", "\"label:  %s\"", "%", "label", ")", "if", "value", "!=", "\"\"", ":", "synsets", ".", "append", "(", "value", ")", "return", "synsets"], "docstring_tokens": ["Returns", "a", "list", "of", "synset", "IDs", "based", "on", "a", "lemma"]}
{"code_tokens": ["def", "get_synset_xml", "(", "self", ",", "syn_id", ")", ":", "http", ",", "resp", ",", "content", "=", "self", ".", "connect", "(", ")", "params", "=", "\"\"", "fragment", "=", "\"\"", "path", "=", "\"cdb_syn\"", "if", "self", ".", "debug", ":", "printf", "(", "\"cornettodb/views/query_remote_syn_id: db_opt: %s\"", "%", "path", ")", "# output_opt: plain, html, xml", "# 'xml' is actually xhtml (with markup), but it is not valid xml!", "# 'plain' is actually valid xml (without markup)", "output_opt", "=", "\"plain\"", "if", "self", ".", "debug", ":", "printf", "(", "\"cornettodb/views/query_remote_syn_id: output_opt: %s\"", "%", "output_opt", ")", "action", "=", "\"runQuery\"", "if", "self", ".", "debug", ":", "printf", "(", "\"cornettodb/views/query_remote_syn_id: action: %s\"", "%", "action", ")", "printf", "(", "\"cornettodb/views/query_remote_syn_id: query: %s\"", "%", "syn_id", ")", "qdict", "=", "{", "}", "qdict", "[", "\"action\"", "]", "=", "action", "qdict", "[", "\"query\"", "]", "=", "syn_id", "qdict", "[", "\"outtype\"", "]", "=", "output_opt", "query", "=", "urllib", ".", "urlencode", "(", "qdict", ")", "db_url_tuple", "=", "(", "self", ".", "scheme", ",", "self", ".", "host", "+", "':'", "+", "str", "(", "self", ".", "port", ")", ",", "path", ",", "params", ",", "query", ",", "fragment", ")", "db_url", "=", "urlparse", ".", "urlunparse", "(", "db_url_tuple", ")", "if", "self", ".", "debug", ":", "printf", "(", "\"db_url: %s\"", "%", "db_url", ")", "resp", ",", "content", "=", "http", ".", "request", "(", "db_url", ",", "\"GET\"", ")", "if", "self", ".", "debug", ":", "printf", "(", "\"resp:\\n%s\"", "%", "resp", ")", "#    printf( \"content:\\n%s\" % content )", "#    printf( \"content is of type: %s\" % type( content ) )        #<type 'str'>", "xml_data", "=", "eval", "(", "content", ")", "return", "etree", ".", "fromstring", "(", "xml_data", ")"], "docstring_tokens": ["call", "cdb_syn", "with", "synset", "identifier", "-", ">", "returns", "the", "synset", "xml", ";"]}
{"code_tokens": ["def", "senses", "(", "self", ",", "bestonly", "=", "False", ")", ":", "l", "=", "[", "]", "for", "word_id", ",", "senses", ",", "distance", "in", "self", ":", "for", "sense", ",", "confidence", "in", "senses", ":", "if", "not", "sense", "in", "l", ":", "l", ".", "append", "(", "sense", ")", "if", "bestonly", ":", "break", "return", "l"], "docstring_tokens": ["Returns", "a", "list", "of", "all", "predicted", "senses"]}
{"code_tokens": ["def", "align", "(", "self", ",", "inputwords", ",", "outputwords", ")", ":", "alignment", "=", "[", "]", "cursor", "=", "0", "for", "inputword", "in", "inputwords", ":", "if", "len", "(", "outputwords", ")", ">", "cursor", "and", "outputwords", "[", "cursor", "]", "==", "inputword", ":", "alignment", ".", "append", "(", "cursor", ")", "cursor", "+=", "1", "elif", "len", "(", "outputwords", ")", ">", "cursor", "+", "1", "and", "outputwords", "[", "cursor", "+", "1", "]", "==", "inputword", ":", "alignment", ".", "append", "(", "cursor", "+", "1", ")", "cursor", "+=", "2", "else", ":", "alignment", ".", "append", "(", "None", ")", "cursor", "+=", "1", "return", "alignment"], "docstring_tokens": ["For", "each", "inputword", "provides", "the", "index", "of", "the", "outputword"]}
{"code_tokens": ["def", "tokenize", "(", "text", ",", "regexps", "=", "TOKENIZERRULES", ")", ":", "for", "i", ",", "regexp", "in", "list", "(", "enumerate", "(", "regexps", ")", ")", ":", "if", "isstring", "(", "regexp", ")", ":", "regexps", "[", "i", "]", "=", "re", ".", "compile", "(", "regexp", ")", "tokens", "=", "[", "]", "begin", "=", "0", "for", "i", ",", "c", "in", "enumerate", "(", "text", ")", ":", "if", "begin", ">", "i", ":", "continue", "elif", "i", "==", "begin", ":", "m", "=", "False", "for", "regexp", "in", "regexps", ":", "m", "=", "regexp", ".", "findall", "(", "text", "[", "i", ":", "i", "+", "300", "]", ")", "if", "m", ":", "tokens", ".", "append", "(", "m", "[", "0", "]", ")", "begin", "=", "i", "+", "len", "(", "m", "[", "0", "]", ")", "break", "if", "m", ":", "continue", "if", "c", "in", "string", ".", "punctuation", "or", "c", "in", "WHITESPACE", ":", "prev", "=", "text", "[", "i", "-", "1", "]", "if", "i", ">", "0", "else", "\"\"", "next", "=", "text", "[", "i", "+", "1", "]", "if", "i", "<", "len", "(", "text", ")", "-", "1", "else", "\"\"", "if", "(", "c", "==", "'.'", "or", "c", "==", "','", ")", "and", "prev", ".", "isdigit", "(", ")", "and", "next", ".", "isdigit", "(", ")", ":", "#punctuation in between numbers, keep as one token", "pass", "elif", "(", "c", "==", "\"'\"", "or", "c", "==", "\"`\"", ")", "and", "prev", ".", "isalpha", "(", ")", "and", "next", ".", "isalpha", "(", ")", ":", "#quote in between chars, keep...", "pass", "elif", "c", "not", "in", "WHITESPACE", "and", "next", "==", "c", ":", "#group clusters of identical punctuation together", "continue", "elif", "c", "==", "'\\r'", "and", "prev", "==", "'\\n'", ":", "#ignore", "begin", "=", "i", "+", "1", "continue", "else", ":", "token", "=", "text", "[", "begin", ":", "i", "]", "if", "token", ":", "tokens", ".", "append", "(", "token", ")", "if", "c", "not", "in", "WHITESPACE", ":", "tokens", ".", "append", "(", "c", ")", "#anything but spaces and newlines (i.e. punctuation) counts as a token too", "begin", "=", "i", "+", "1", "#set the begin cursor", "if", "begin", "<=", "len", "(", "text", ")", "-", "1", ":", "token", "=", "text", "[", "begin", ":", "]", "tokens", ".", "append", "(", "token", ")", "return", "tokens"], "docstring_tokens": ["Tokenizes", "a", "string", "and", "returns", "a", "list", "of", "tokens"]}
{"code_tokens": ["def", "strip_accents", "(", "s", ",", "encoding", "=", "'utf-8'", ")", ":", "if", "sys", ".", "version", "<", "'3'", ":", "if", "isinstance", "(", "s", ",", "unicode", ")", ":", "return", "unicodedata", ".", "normalize", "(", "'NFKD'", ",", "s", ")", ".", "encode", "(", "'ASCII'", ",", "'ignore'", ")", "else", ":", "return", "unicodedata", ".", "normalize", "(", "'NFKD'", ",", "unicode", "(", "s", ",", "encoding", ")", ")", ".", "encode", "(", "'ASCII'", ",", "'ignore'", ")", "else", ":", "if", "isinstance", "(", "s", ",", "bytes", ")", ":", "s", "=", "str", "(", "s", ",", "encoding", ")", "return", "str", "(", "unicodedata", ".", "normalize", "(", "'NFKD'", ",", "s", ")", ".", "encode", "(", "'ASCII'", ",", "'ignore'", ")", ",", "'ascii'", ")"], "docstring_tokens": ["Strip", "characters", "with", "diacritics", "and", "return", "a", "flat", "ascii", "representation"]}
{"code_tokens": ["def", "swap", "(", "tokens", ",", "maxdist", "=", "2", ")", ":", "assert", "maxdist", ">=", "2", "tokens", "=", "list", "(", "tokens", ")", "if", "maxdist", ">", "len", "(", "tokens", ")", ":", "maxdist", "=", "len", "(", "tokens", ")", "l", "=", "len", "(", "tokens", ")", "for", "i", "in", "range", "(", "0", ",", "l", "-", "1", ")", ":", "for", "permutation", "in", "permutations", "(", "tokens", "[", "i", ":", "i", "+", "maxdist", "]", ")", ":", "if", "permutation", "!=", "tuple", "(", "tokens", "[", "i", ":", "i", "+", "maxdist", "]", ")", ":", "newtokens", "=", "tokens", "[", ":", "i", "]", "newtokens", "+=", "permutation", "newtokens", "+=", "tokens", "[", "i", "+", "maxdist", ":", "]", "yield", "newtokens", "if", "maxdist", "==", "len", "(", "tokens", ")", ":", "break"], "docstring_tokens": ["Perform", "a", "swap", "operation", "on", "a", "sequence", "of", "tokens", "exhaustively", "swapping", "all", "tokens", "up", "to", "the", "maximum", "specified", "distance", ".", "This", "is", "a", "subset", "of", "all", "permutations", "."]}
{"code_tokens": ["def", "find_keyword_in_context", "(", "tokens", ",", "keyword", ",", "contextsize", "=", "1", ")", ":", "if", "isinstance", "(", "keyword", ",", "tuple", ")", "and", "isinstance", "(", "keyword", ",", "list", ")", ":", "l", "=", "len", "(", "keyword", ")", "else", ":", "keyword", "=", "(", "keyword", ",", ")", "l", "=", "1", "n", "=", "l", "+", "contextsize", "*", "2", "focuspos", "=", "contextsize", "+", "1", "for", "ngram", "in", "Windower", "(", "tokens", ",", "n", ",", "None", ",", "None", ")", ":", "if", "ngram", "[", "focuspos", ":", "focuspos", "+", "l", "]", "==", "keyword", ":", "yield", "ngram", "[", ":", "focuspos", "]", ",", "ngram", "[", "focuspos", ":", "focuspos", "+", "l", "]", ",", "ngram", "[", "focuspos", "+", "l", "+", "1", ":", "]"], "docstring_tokens": ["Find", "a", "keyword", "in", "a", "particular", "sequence", "of", "tokens", "and", "return", "the", "local", "context", ".", "Contextsize", "is", "the", "number", "of", "words", "to", "the", "left", "and", "right", ".", "The", "keyword", "may", "have", "multiple", "word", "in", "which", "case", "it", "should", "to", "passed", "as", "a", "tuple", "or", "list"]}
{"code_tokens": ["def", "randomprune", "(", "self", ",", "n", ")", ":", "self", ".", "data", "=", "random", ".", "sample", "(", "self", ".", "data", ",", "n", ")"], "docstring_tokens": ["prune", "down", "to", "n", "items", "at", "random", "disregarding", "their", "score"]}
{"code_tokens": ["def", "append", "(", "self", ",", "item", ")", ":", "if", "not", "isinstance", "(", "item", ",", "Tree", ")", ":", "return", "ValueError", "(", "\"Can only append items of type Tree\"", ")", "if", "not", "self", ".", "children", ":", "self", ".", "children", "=", "[", "]", "item", ".", "parent", "=", "self", "self", ".", "children", ".", "append", "(", "item", ")"], "docstring_tokens": ["Add", "an", "item", "to", "the", "Tree"]}
{"code_tokens": ["def", "size", "(", "self", ")", ":", "if", "self", ".", "children", ":", "return", "sum", "(", "(", "c", ".", "size", "(", ")", "for", "c", "in", "self", ".", "children", ".", "values", "(", ")", ")", ")", "+", "1", "else", ":", "return", "1"], "docstring_tokens": ["Size", "is", "number", "of", "nodes", "under", "the", "trie", "including", "the", "current", "node"]}
{"code_tokens": ["def", "validate", "(", "self", ",", "formats_dir", "=", "\"../formats/\"", ")", ":", "#TODO: download XSD from web", "if", "self", ".", "inline", ":", "xmlschema", "=", "ElementTree", ".", "XMLSchema", "(", "ElementTree", ".", "parse", "(", "StringIO", "(", "\"\\n\"", ".", "join", "(", "open", "(", "formats_dir", "+", "\"dcoi-dsc.xsd\"", ")", ".", "readlines", "(", ")", ")", ")", ")", ")", "xmlschema", ".", "assertValid", "(", "self", ".", "tree", ")", "#return xmlschema.validate(self)", "else", ":", "xmlschema", "=", "ElementTree", ".", "XMLSchema", "(", "ElementTree", ".", "parse", "(", "StringIO", "(", "\"\\n\"", ".", "join", "(", "open", "(", "formats_dir", "+", "\"dutchsemcor-standalone.xsd\"", ")", ".", "readlines", "(", ")", ")", ")", ")", ")", "xmlschema", ".", "assertValid", "(", "self", ".", "tree", ")"], "docstring_tokens": ["checks", "if", "the", "document", "is", "valid"]}
{"code_tokens": ["def", "xpath", "(", "self", ",", "expression", ")", ":", "global", "namespaces", "return", "self", ".", "tree", ".", "xpath", "(", "expression", ",", "namespaces", "=", "namespaces", ")"], "docstring_tokens": ["Executes", "an", "xpath", "expression", "using", "the", "correct", "namespaces"]}
{"code_tokens": ["def", "align", "(", "self", ",", "referencewords", ",", "datatuple", ")", ":", "targetwords", "=", "[", "]", "for", "i", ",", "(", "word", ",", "lemma", ",", "postag", ")", "in", "enumerate", "(", "zip", "(", "datatuple", "[", "0", "]", ",", "datatuple", "[", "1", "]", ",", "datatuple", "[", "2", "]", ")", ")", ":", "if", "word", ":", "subwords", "=", "word", ".", "split", "(", "\"_\"", ")", "for", "w", "in", "subwords", ":", "#split multiword expressions", "targetwords", ".", "append", "(", "(", "w", ",", "lemma", ",", "postag", ",", "i", ",", "len", "(", "subwords", ")", ">", "1", ")", ")", "#word, lemma, pos, index, multiword? ", "referencewords", "=", "[", "w", ".", "lower", "(", ")", "for", "w", "in", "referencewords", "]", "alignment", "=", "[", "]", "for", "i", ",", "referenceword", "in", "enumerate", "(", "referencewords", ")", ":", "found", "=", "False", "best", "=", "0", "distance", "=", "999999", "for", "j", ",", "(", "targetword", ",", "lemma", ",", "pos", ",", "index", ",", "multiword", ")", "in", "enumerate", "(", "targetwords", ")", ":", "if", "referenceword", "==", "targetword", "and", "abs", "(", "i", "-", "j", ")", "<", "distance", ":", "found", "=", "True", "best", "=", "j", "distance", "=", "abs", "(", "i", "-", "j", ")", "if", "found", ":", "alignment", ".", "append", "(", "targetwords", "[", "best", "]", ")", "else", ":", "alignment", ".", "append", "(", "(", "None", ",", "None", ",", "None", ",", "None", ",", "False", ")", ")", "#no alignment found        ", "return", "alignment"], "docstring_tokens": ["align", "the", "reference", "sentence", "with", "the", "tagged", "data"]}
{"code_tokens": ["def", "build", "(", "self", ",", "*", "*", "kwargs", ")", ":", "self", ".", "lexer", "=", "ply", ".", "lex", ".", "lex", "(", "object", "=", "self", ",", "*", "*", "kwargs", ")"], "docstring_tokens": ["Build", "the", "lexer", "."]}
{"code_tokens": ["def", "is_authorized", "(", "self", ",", "request", ")", ":", "if", "self", ".", "_is_request_in_include_path", "(", "request", ")", ":", "if", "self", ".", "_is_request_in_exclude_path", "(", "request", ")", ":", "return", "True", "else", ":", "auth", "=", "request", ".", "authorization", "if", "auth", "and", "auth", "[", "0", "]", "==", "'Basic'", ":", "credentials", "=", "b64decode", "(", "auth", "[", "1", "]", ")", ".", "decode", "(", "'UTF-8'", ")", "username", ",", "password", "=", "credentials", ".", "split", "(", "':'", ",", "1", ")", "return", "self", ".", "_users", ".", "get", "(", "username", ")", "==", "password", "else", ":", "return", "False", "else", ":", "return", "True"], "docstring_tokens": ["Check", "if", "the", "user", "is", "authenticated", "for", "the", "given", "request", "."]}
{"code_tokens": ["def", "_login", "(", "self", ",", "environ", ",", "start_response", ")", ":", "response", "=", "HTTPUnauthorized", "(", ")", "response", ".", "www_authenticate", "=", "(", "'Basic'", ",", "{", "'realm'", ":", "self", ".", "_realm", "}", ")", "return", "response", "(", "environ", ",", "start_response", ")"], "docstring_tokens": ["Send", "a", "login", "response", "back", "to", "the", "client", "."]}
{"code_tokens": ["def", "_is_request_in_include_path", "(", "self", ",", "request", ")", ":", "if", "self", ".", "_include_paths", ":", "for", "path", "in", "self", ".", "_include_paths", ":", "if", "request", ".", "path", ".", "startswith", "(", "path", ")", ":", "return", "True", "return", "False", "else", ":", "return", "True"], "docstring_tokens": ["Check", "if", "the", "request", "path", "is", "in", "the", "_include_paths", "list", "."]}
{"code_tokens": ["def", "_is_request_in_exclude_path", "(", "self", ",", "request", ")", ":", "if", "self", ".", "_exclude_paths", ":", "for", "path", "in", "self", ".", "_exclude_paths", ":", "if", "request", ".", "path", ".", "startswith", "(", "path", ")", ":", "return", "True", "return", "False", "else", ":", "return", "False"], "docstring_tokens": ["Check", "if", "the", "request", "path", "is", "in", "the", "_exclude_paths", "list"]}
{"code_tokens": ["def", "bootstrap_prompt", "(", "prompt_kwargs", ",", "group", ")", ":", "prompt_kwargs", "=", "prompt_kwargs", "or", "{", "}", "defaults", "=", "{", "\"history\"", ":", "InMemoryHistory", "(", ")", ",", "\"completer\"", ":", "ClickCompleter", "(", "group", ")", ",", "\"message\"", ":", "u\"> \"", ",", "}", "for", "key", "in", "defaults", ":", "default_value", "=", "defaults", "[", "key", "]", "if", "key", "not", "in", "prompt_kwargs", ":", "prompt_kwargs", "[", "key", "]", "=", "default_value", "return", "prompt_kwargs"], "docstring_tokens": ["Bootstrap", "prompt_toolkit", "kwargs", "or", "use", "user", "defined", "values", "."]}
{"code_tokens": ["def", "repl", "(", "# noqa: C901", "old_ctx", ",", "prompt_kwargs", "=", "None", ",", "allow_system_commands", "=", "True", ",", "allow_internal_commands", "=", "True", ",", ")", ":", "# parent should be available, but we're not going to bother if not", "group_ctx", "=", "old_ctx", ".", "parent", "or", "old_ctx", "group", "=", "group_ctx", ".", "command", "isatty", "=", "sys", ".", "stdin", ".", "isatty", "(", ")", "# Delete the REPL command from those available, as we don't want to allow", "# nesting REPLs (note: pass `None` to `pop` as we don't want to error if", "# REPL command already not present for some reason).", "repl_command_name", "=", "old_ctx", ".", "command", ".", "name", "if", "isinstance", "(", "group_ctx", ".", "command", ",", "click", ".", "CommandCollection", ")", ":", "available_commands", "=", "{", "cmd_name", ":", "cmd_obj", "for", "source", "in", "group_ctx", ".", "command", ".", "sources", "for", "cmd_name", ",", "cmd_obj", "in", "source", ".", "commands", ".", "items", "(", ")", "}", "else", ":", "available_commands", "=", "group_ctx", ".", "command", ".", "commands", "available_commands", ".", "pop", "(", "repl_command_name", ",", "None", ")", "prompt_kwargs", "=", "bootstrap_prompt", "(", "prompt_kwargs", ",", "group", ")", "if", "isatty", ":", "def", "get_command", "(", ")", ":", "return", "prompt", "(", "*", "*", "prompt_kwargs", ")", "else", ":", "get_command", "=", "sys", ".", "stdin", ".", "readline", "while", "True", ":", "try", ":", "command", "=", "get_command", "(", ")", "except", "KeyboardInterrupt", ":", "continue", "except", "EOFError", ":", "break", "if", "not", "command", ":", "if", "isatty", ":", "continue", "else", ":", "break", "if", "allow_system_commands", "and", "dispatch_repl_commands", "(", "command", ")", ":", "continue", "if", "allow_internal_commands", ":", "try", ":", "result", "=", "handle_internal_commands", "(", "command", ")", "if", "isinstance", "(", "result", ",", "six", ".", "string_types", ")", ":", "click", ".", "echo", "(", "result", ")", "continue", "except", "ExitReplException", ":", "break", "try", ":", "args", "=", "shlex", ".", "split", "(", "command", ")", "except", "ValueError", "as", "e", ":", "click", ".", "echo", "(", "\"{}: {}\"", ".", "format", "(", "type", "(", "e", ")", ".", "__name__", ",", "e", ")", ")", "continue", "try", ":", "with", "group", ".", "make_context", "(", "None", ",", "args", ",", "parent", "=", "group_ctx", ")", "as", "ctx", ":", "group", ".", "invoke", "(", "ctx", ")", "ctx", ".", "exit", "(", ")", "except", "click", ".", "ClickException", "as", "e", ":", "e", ".", "show", "(", ")", "except", "ClickExit", ":", "pass", "except", "SystemExit", ":", "pass", "except", "ExitReplException", ":", "break"], "docstring_tokens": ["Start", "an", "interactive", "shell", ".", "All", "subcommands", "are", "available", "in", "it", "."]}
{"code_tokens": ["def", "handle_internal_commands", "(", "command", ")", ":", "if", "command", ".", "startswith", "(", "\":\"", ")", ":", "target", "=", "_get_registered_target", "(", "command", "[", "1", ":", "]", ",", "default", "=", "None", ")", "if", "target", ":", "return", "target", "(", ")"], "docstring_tokens": ["Run", "repl", "-", "internal", "commands", "."]}
{"code_tokens": ["def", "node_definitions", "(", "id_fetcher", ",", "type_resolver", "=", "None", ",", "id_resolver", "=", "None", ")", ":", "node_interface", "=", "GraphQLInterfaceType", "(", "'Node'", ",", "description", "=", "'An object with an ID'", ",", "fields", "=", "lambda", ":", "OrderedDict", "(", "(", "(", "'id'", ",", "GraphQLField", "(", "GraphQLNonNull", "(", "GraphQLID", ")", ",", "description", "=", "'The id of the object.'", ",", "resolver", "=", "id_resolver", ",", ")", ")", ",", ")", ")", ",", "resolve_type", "=", "type_resolver", ")", "node_field", "=", "GraphQLField", "(", "node_interface", ",", "description", "=", "'Fetches an object given its ID'", ",", "args", "=", "OrderedDict", "(", "(", "(", "'id'", ",", "GraphQLArgument", "(", "GraphQLNonNull", "(", "GraphQLID", ")", ",", "description", "=", "'The ID of an object'", ")", ")", ",", ")", ")", ",", "resolver", "=", "lambda", "obj", ",", "args", ",", "*", "_", ":", "id_fetcher", "(", "args", ".", "get", "(", "'id'", ")", ",", "*", "_", ")", ")", "return", "node_interface", ",", "node_field"], "docstring_tokens": ["Given", "a", "function", "to", "map", "from", "an", "ID", "to", "an", "underlying", "object", "and", "a", "function", "to", "map", "from", "an", "underlying", "object", "to", "the", "concrete", "GraphQLObjectType", "it", "corresponds", "to", "constructs", "a", "Node", "interface", "that", "objects", "can", "implement", "and", "a", "field", "config", "for", "a", "node", "root", "field", "."]}
{"code_tokens": ["def", "from_global_id", "(", "global_id", ")", ":", "unbased_global_id", "=", "unbase64", "(", "global_id", ")", "_type", ",", "_id", "=", "unbased_global_id", ".", "split", "(", "':'", ",", "1", ")", "return", "_type", ",", "_id"], "docstring_tokens": ["Takes", "the", "global", "ID", "created", "by", "toGlobalID", "and", "retuns", "the", "type", "name", "and", "ID", "used", "to", "create", "it", "."]}
{"code_tokens": ["def", "global_id_field", "(", "type_name", ",", "id_fetcher", "=", "None", ")", ":", "return", "GraphQLField", "(", "GraphQLNonNull", "(", "GraphQLID", ")", ",", "description", "=", "'The ID of an object'", ",", "resolver", "=", "lambda", "obj", ",", "args", ",", "context", ",", "info", ":", "to_global_id", "(", "type_name", "or", "info", ".", "parent_type", ".", "name", ",", "id_fetcher", "(", "obj", ",", "context", ",", "info", ")", "if", "id_fetcher", "else", "obj", ".", "id", ")", ")"], "docstring_tokens": ["Creates", "the", "configuration", "for", "an", "id", "field", "on", "a", "node", "using", "to_global_id", "to", "construct", "the", "ID", "from", "the", "provided", "typename", ".", "The", "type", "-", "specific", "ID", "is", "fetcher", "by", "calling", "id_fetcher", "on", "the", "object", "or", "if", "not", "provided", "by", "accessing", "the", "id", "property", "on", "the", "object", "."]}
{"code_tokens": ["def", "connection_from_list", "(", "data", ",", "args", "=", "None", ",", "*", "*", "kwargs", ")", ":", "_len", "=", "len", "(", "data", ")", "return", "connection_from_list_slice", "(", "data", ",", "args", ",", "slice_start", "=", "0", ",", "list_length", "=", "_len", ",", "list_slice_length", "=", "_len", ",", "*", "*", "kwargs", ")"], "docstring_tokens": ["A", "simple", "function", "that", "accepts", "an", "array", "and", "connection", "arguments", "and", "returns", "a", "connection", "object", "for", "use", "in", "GraphQL", ".", "It", "uses", "array", "offsets", "as", "pagination", "so", "pagination", "will", "only", "work", "if", "the", "array", "is", "static", "."]}
{"code_tokens": ["def", "connection_from_promised_list", "(", "data_promise", ",", "args", "=", "None", ",", "*", "*", "kwargs", ")", ":", "return", "data_promise", ".", "then", "(", "lambda", "data", ":", "connection_from_list", "(", "data", ",", "args", ",", "*", "*", "kwargs", ")", ")"], "docstring_tokens": ["A", "version", "of", "connectionFromArray", "that", "takes", "a", "promised", "array", "and", "returns", "a", "promised", "connection", "."]}
{"code_tokens": ["def", "cursor_for_object_in_connection", "(", "data", ",", "_object", ")", ":", "if", "_object", "not", "in", "data", ":", "return", "None", "offset", "=", "data", ".", "index", "(", "_object", ")", "return", "offset_to_cursor", "(", "offset", ")"], "docstring_tokens": ["Return", "the", "cursor", "associated", "with", "an", "object", "in", "an", "array", "."]}
{"code_tokens": ["def", "get_offset_with_default", "(", "cursor", "=", "None", ",", "default_offset", "=", "0", ")", ":", "if", "not", "is_str", "(", "cursor", ")", ":", "return", "default_offset", "offset", "=", "cursor_to_offset", "(", "cursor", ")", "try", ":", "return", "int", "(", "offset", ")", "except", ":", "return", "default_offset"], "docstring_tokens": ["Given", "an", "optional", "cursor", "and", "a", "default", "offset", "returns", "the", "offset", "to", "use", ";", "if", "the", "cursor", "contains", "a", "valid", "offset", "that", "will", "be", "used", "otherwise", "it", "will", "be", "the", "default", "."]}
{"code_tokens": ["def", "generate", "(", "data", ",", "iterations", "=", "1000", ",", "force_strength", "=", "5.0", ",", "dampening", "=", "0.01", ",", "max_velocity", "=", "2.0", ",", "max_distance", "=", "50", ",", "is_3d", "=", "True", ")", ":", "edges", "=", "[", "{", "'source'", ":", "s", ",", "'target'", ":", "t", "}", "for", "s", ",", "t", "in", "data", "]", "nodes", "=", "force_directed_layout", ".", "run", "(", "edges", ",", "iterations", ",", "force_strength", ",", "dampening", ",", "max_velocity", ",", "max_distance", ",", "is_3d", ")", "return", "{", "'edges'", ":", "edges", ",", "'nodes'", ":", "nodes", "}"], "docstring_tokens": ["Runs", "a", "force", "-", "directed", "algorithm", "on", "a", "graph", "returning", "a", "data", "structure", "."]}
{"code_tokens": ["def", "compress", "(", "obj", ")", ":", "return", "json", ".", "dumps", "(", "obj", ",", "sort_keys", "=", "True", ",", "separators", "=", "(", "','", ",", "':'", ")", ",", "cls", "=", "CustomEncoder", ")"], "docstring_tokens": ["Outputs", "json", "without", "whitespace", "."]}
{"code_tokens": ["def", "dumps", "(", "obj", ")", ":", "return", "json", ".", "dumps", "(", "obj", ",", "indent", "=", "4", ",", "sort_keys", "=", "True", ",", "cls", "=", "CustomEncoder", ")"], "docstring_tokens": ["Outputs", "json", "with", "formatting", "edits", "+", "object", "handling", "."]}
{"code_tokens": ["def", "encode", "(", "self", ",", "obj", ")", ":", "s", "=", "super", "(", "CustomEncoder", ",", "self", ")", ".", "encode", "(", "obj", ")", "# If uncompressed, postprocess for formatting", "if", "len", "(", "s", ".", "splitlines", "(", ")", ")", ">", "1", ":", "s", "=", "self", ".", "postprocess", "(", "s", ")", "return", "s"], "docstring_tokens": ["Fired", "for", "every", "object", "."]}
{"code_tokens": ["def", "postprocess", "(", "self", ",", "json_string", ")", ":", "is_compressing", ",", "is_hash", ",", "compressed", ",", "spaces", "=", "False", ",", "False", ",", "[", "]", ",", "0", "for", "row", "in", "json_string", ".", "split", "(", "'\\n'", ")", ":", "if", "is_compressing", ":", "if", "(", "row", "[", ":", "spaces", "+", "5", "]", "==", "' '", "*", "(", "spaces", "+", "4", ")", "+", "(", "'\"'", "if", "is_hash", "else", "'{'", ")", ")", ":", "compressed", ".", "append", "(", "row", ".", "rstrip", "(", ")", ")", "elif", "(", "len", "(", "row", ")", ">", "spaces", "and", "row", "[", ":", "spaces", "]", "==", "' '", "*", "spaces", "and", "re", ".", "match", "(", "'[\\]\\}],?'", ",", "row", "[", "spaces", ":", "]", ".", "rstrip", "(", ")", ")", ")", ":", "compressed", ".", "append", "(", "row", ".", "rstrip", "(", ")", ")", "is_compressing", "=", "False", "else", ":", "compressed", "[", "-", "1", "]", "+=", "' '", "+", "row", ".", "strip", "(", ")", "else", ":", "compressed", ".", "append", "(", "row", ".", "rstrip", "(", ")", ")", "if", "any", "(", "a", "in", "row", "for", "a", "in", "[", "'edges'", ",", "'nodes'", "]", ")", ":", "# Fix to handle issues that arise with empty lists", "if", "'[]'", "in", "row", ":", "continue", "spaces", "=", "sum", "(", "1", "for", "_", "in", "takewhile", "(", "str", ".", "isspace", ",", "row", ")", ")", "is_compressing", ",", "is_hash", "=", "True", ",", "'{'", "in", "row", "return", "'\\n'", ".", "join", "(", "compressed", ")"], "docstring_tokens": ["Displays", "each", "entry", "on", "its", "own", "line", "."]}
{"code_tokens": ["def", "run", "(", "edges", ",", "iterations", "=", "1000", ",", "force_strength", "=", "5.0", ",", "dampening", "=", "0.01", ",", "max_velocity", "=", "2.0", ",", "max_distance", "=", "50", ",", "is_3d", "=", "True", ")", ":", "# Get a list of node ids from the edge data", "nodes", "=", "set", "(", "e", "[", "'source'", "]", "for", "e", "in", "edges", ")", "|", "set", "(", "e", "[", "'target'", "]", "for", "e", "in", "edges", ")", "# Convert to a data-storing object and initialize some values", "d", "=", "3", "if", "is_3d", "else", "2", "nodes", "=", "{", "n", ":", "{", "'velocity'", ":", "[", "0.0", "]", "*", "d", ",", "'force'", ":", "[", "0.0", "]", "*", "d", "}", "for", "n", "in", "nodes", "}", "# Repeat n times (is there a more Pythonic way to do this?)", "for", "_", "in", "repeat", "(", "None", ",", "iterations", ")", ":", "# Add in Coulomb-esque node-node repulsive forces", "for", "node1", ",", "node2", "in", "combinations", "(", "nodes", ".", "values", "(", ")", ",", "2", ")", ":", "_coulomb", "(", "node1", ",", "node2", ",", "force_strength", ",", "max_distance", ")", "# And Hooke-esque edge spring forces", "for", "edge", "in", "edges", ":", "_hooke", "(", "nodes", "[", "edge", "[", "'source'", "]", "]", ",", "nodes", "[", "edge", "[", "'target'", "]", "]", ",", "force_strength", "*", "edge", ".", "get", "(", "'size'", ",", "1", ")", ",", "max_distance", ")", "# Move by resultant force", "for", "node", "in", "nodes", ".", "values", "(", ")", ":", "# Constrain the force to the bounds specified by input parameter", "force", "=", "[", "_constrain", "(", "dampening", "*", "f", ",", "-", "max_velocity", ",", "max_velocity", ")", "for", "f", "in", "node", "[", "'force'", "]", "]", "# Update velocities and reset force", "node", "[", "'velocity'", "]", "=", "[", "v", "+", "dv", "for", "v", ",", "dv", "in", "zip", "(", "node", "[", "'velocity'", "]", ",", "force", ")", "]", "node", "[", "'force'", "]", "=", "[", "0", "]", "*", "d", "# Clean and return", "for", "node", "in", "nodes", ".", "values", "(", ")", ":", "del", "node", "[", "'force'", "]", "node", "[", "'location'", "]", "=", "node", "[", "'velocity'", "]", "del", "node", "[", "'velocity'", "]", "# Even if it's 2D, let's specify three dimensions", "if", "not", "is_3d", ":", "node", "[", "'location'", "]", "+=", "[", "0.0", "]", "return", "nodes"], "docstring_tokens": ["Runs", "a", "force", "-", "directed", "-", "layout", "algorithm", "on", "the", "input", "graph", "."]}
{"code_tokens": ["def", "_coulomb", "(", "n1", ",", "n2", ",", "k", ",", "r", ")", ":", "# Get relevant positional data", "delta", "=", "[", "x2", "-", "x1", "for", "x1", ",", "x2", "in", "zip", "(", "n1", "[", "'velocity'", "]", ",", "n2", "[", "'velocity'", "]", ")", "]", "distance", "=", "sqrt", "(", "sum", "(", "d", "**", "2", "for", "d", "in", "delta", ")", ")", "# If the deltas are too small, use random values to keep things moving", "if", "distance", "<", "0.1", ":", "delta", "=", "[", "uniform", "(", "0.1", ",", "0.2", ")", "for", "_", "in", "repeat", "(", "None", ",", "3", ")", "]", "distance", "=", "sqrt", "(", "sum", "(", "d", "**", "2", "for", "d", "in", "delta", ")", ")", "# If the distance isn't huge (ie. Coulomb is negligible), calculate", "if", "distance", "<", "r", ":", "force", "=", "(", "k", "/", "distance", ")", "**", "2", "n1", "[", "'force'", "]", "=", "[", "f", "-", "force", "*", "d", "for", "f", ",", "d", "in", "zip", "(", "n1", "[", "'force'", "]", ",", "delta", ")", "]", "n2", "[", "'force'", "]", "=", "[", "f", "+", "force", "*", "d", "for", "f", ",", "d", "in", "zip", "(", "n2", "[", "'force'", "]", ",", "delta", ")", "]"], "docstring_tokens": ["Calculates", "Coulomb", "forces", "and", "updates", "node", "data", "."]}
{"code_tokens": ["def", "run_step", "(", "context", ")", ":", "logger", ".", "debug", "(", "\"started\"", ")", "context", ".", "clear", "(", ")", "logger", ".", "info", "(", "f\"Context wiped. New context size: {len(context)}\"", ")", "logger", ".", "debug", "(", "\"done\"", ")"], "docstring_tokens": ["Wipe", "the", "entire", "context", "."]}
{"code_tokens": ["def", "run_step", "(", "context", ")", ":", "logger", ".", "debug", "(", "\"started\"", ")", "context", ".", "assert_key_has_value", "(", "key", "=", "'pathCheck'", ",", "caller", "=", "__name__", ")", "paths_to_check", "=", "context", "[", "'pathCheck'", "]", "if", "not", "paths_to_check", ":", "raise", "KeyInContextHasNoValueError", "(", "\"context['pathCheck'] must have a \"", "f\"value for {__name__}.\"", ")", "# pathsToCheck can be a string or a list in case there are multiple paths", "if", "isinstance", "(", "paths_to_check", ",", "list", ")", ":", "check_me", "=", "paths_to_check", "else", ":", "# assuming it's a str/path at this point", "check_me", "=", "[", "paths_to_check", "]", "out", "=", "{", "}", "total_found", "=", "0", "for", "path", "in", "check_me", ":", "logger", ".", "debug", "(", "f\"checking path: {path}\"", ")", "formatted_path", "=", "context", ".", "get_formatted_string", "(", "path", ")", "found_paths", "=", "pypyr", ".", "utils", ".", "filesystem", ".", "get_glob", "(", "formatted_path", ")", "no_of_paths", "=", "len", "(", "found_paths", ")", "out", "[", "path", "]", "=", "{", "'exists'", ":", "no_of_paths", ">", "0", ",", "'count'", ":", "no_of_paths", ",", "'found'", ":", "found_paths", "}", "total_found", "=", "total_found", "+", "no_of_paths", "context", "[", "'pathCheckOut'", "]", "=", "out", "logger", ".", "info", "(", "f'checked {len(out)} path(s) and found {total_found}'", ")", "logger", ".", "debug", "(", "\"done\"", ")"], "docstring_tokens": ["pypyr", "step", "that", "checks", "if", "a", "file", "or", "directory", "path", "exists", "."]}
{"code_tokens": ["def", "run_step", "(", "context", ")", ":", "logger", ".", "debug", "(", "\"started\"", ")", "context", ".", "assert_child_key_has_value", "(", "'fileWriteJson'", ",", "'path'", ",", "__name__", ")", "out_path", "=", "context", ".", "get_formatted_string", "(", "context", "[", "'fileWriteJson'", "]", "[", "'path'", "]", ")", "# doing it like this to safeguard against accidentally dumping all context", "# with potentially sensitive values in it to disk if payload exists but is", "# None.", "is_payload_specified", "=", "'payload'", "in", "context", "[", "'fileWriteJson'", "]", "logger", ".", "debug", "(", "f\"opening destination file for writing: {out_path}\"", ")", "os", ".", "makedirs", "(", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "out_path", ")", ")", ",", "exist_ok", "=", "True", ")", "with", "open", "(", "out_path", ",", "'w'", ")", "as", "outfile", ":", "if", "is_payload_specified", ":", "payload", "=", "context", "[", "'fileWriteJson'", "]", "[", "'payload'", "]", "formatted_iterable", "=", "context", ".", "get_formatted_iterable", "(", "payload", ")", "else", ":", "formatted_iterable", "=", "context", ".", "get_formatted_iterable", "(", "context", ")", "json", ".", "dump", "(", "formatted_iterable", ",", "outfile", ",", "indent", "=", "2", ",", "ensure_ascii", "=", "False", ")", "logger", ".", "info", "(", "f\"formatted context content and wrote to {out_path}\"", ")", "logger", ".", "debug", "(", "\"done\"", ")"], "docstring_tokens": ["Write", "payload", "out", "to", "json", "file", "."]}
{"code_tokens": ["def", "run_step", "(", "context", ")", ":", "logger", ".", "debug", "(", "\"started\"", ")", "(", "pipeline_name", ",", "use_parent_context", ",", "pipe_arg", ",", "skip_parse", ",", "raise_error", ",", "loader", ",", ")", "=", "get_arguments", "(", "context", ")", "try", ":", "if", "use_parent_context", ":", "logger", ".", "info", "(", "f\"pyping {pipeline_name}, using parent context.\"", ")", "pipelinerunner", ".", "load_and_run_pipeline", "(", "pipeline_name", "=", "pipeline_name", ",", "pipeline_context_input", "=", "pipe_arg", ",", "context", "=", "context", ",", "parse_input", "=", "not", "skip_parse", ",", "loader", "=", "loader", ")", "else", ":", "logger", ".", "info", "(", "f\"pyping {pipeline_name}, without parent context.\"", ")", "pipelinerunner", ".", "load_and_run_pipeline", "(", "pipeline_name", "=", "pipeline_name", ",", "pipeline_context_input", "=", "pipe_arg", ",", "working_dir", "=", "context", ".", "working_dir", ",", "parse_input", "=", "not", "skip_parse", ",", "loader", "=", "loader", ")", "logger", ".", "info", "(", "f\"pyped {pipeline_name}.\"", ")", "except", "Exception", "as", "ex_info", ":", "# yes, yes, don't catch Exception. Have to, though, in order to swallow", "# errs if !raise_error", "logger", ".", "error", "(", "f\"Something went wrong pyping {pipeline_name}. \"", "f\"{type(ex_info).__name__}: {ex_info}\"", ")", "if", "raise_error", ":", "logger", ".", "debug", "(", "\"Raising original exception to caller.\"", ")", "raise", "else", ":", "logger", ".", "debug", "(", "f\"raiseError is False. Swallowing error in {pipeline_name}.\"", ")", "logger", ".", "debug", "(", "\"done\"", ")"], "docstring_tokens": ["Run", "another", "pipeline", "from", "this", "step", "."]}
{"code_tokens": ["def", "get_arguments", "(", "context", ")", ":", "context", ".", "assert_key_has_value", "(", "key", "=", "'pype'", ",", "caller", "=", "__name__", ")", "pype", "=", "context", ".", "get_formatted", "(", "'pype'", ")", "try", ":", "pipeline_name", "=", "pype", "[", "'name'", "]", "if", "pipeline_name", "is", "None", ":", "raise", "KeyInContextHasNoValueError", "(", "\"pypyr.steps.pype ['pype']['name'] exists but is empty.\"", ")", "except", "KeyError", "as", "err", ":", "raise", "KeyNotInContextError", "(", "\"pypyr.steps.pype missing 'name' in the 'pype' context item. \"", "\"You need to specify the pipeline name to run another \"", "\"pipeline.\"", ")", "from", "err", "use_parent_context", "=", "pype", ".", "get", "(", "'useParentContext'", ",", "True", ")", "pipe_arg", "=", "pype", ".", "get", "(", "'pipeArg'", ",", "None", ")", "skip_parse", "=", "pype", ".", "get", "(", "'skipParse'", ",", "True", ")", "raise_error", "=", "pype", ".", "get", "(", "'raiseError'", ",", "True", ")", "loader", "=", "pype", ".", "get", "(", "'loader'", ",", "None", ")", "return", "(", "pipeline_name", ",", "use_parent_context", ",", "pipe_arg", ",", "skip_parse", ",", "raise_error", ",", "loader", ",", ")"], "docstring_tokens": ["Parse", "arguments", "for", "pype", "from", "context", "and", "assign", "default", "values", "."]}
{"code_tokens": ["def", "get_pipeline_path", "(", "pipeline_name", ",", "working_directory", ")", ":", "logger", ".", "debug", "(", "\"starting\"", ")", "# look for name.yaml in the pipelines/ sub-directory", "logger", ".", "debug", "(", "f\"current directory is {working_directory}\"", ")", "# looking for {cwd}/pipelines/[pipeline_name].yaml", "pipeline_path", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "working_directory", ",", "'pipelines'", ",", "pipeline_name", "+", "'.yaml'", ")", ")", "if", "os", ".", "path", ".", "isfile", "(", "pipeline_path", ")", ":", "logger", ".", "debug", "(", "f\"Found {pipeline_path}\"", ")", "else", ":", "logger", ".", "debug", "(", "f\"{pipeline_name} not found in current \"", "\"directory/pipelines folder. Looking in pypyr install \"", "\"directory instead.\"", ")", "pypyr_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ")", "logger", ".", "debug", "(", "f\"pypyr installation directory is: {pypyr_dir}\"", ")", "pipeline_path", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "pypyr_dir", ",", "'pipelines'", ",", "pipeline_name", "+", "'.yaml'", ")", ")", "if", "os", ".", "path", ".", "isfile", "(", "pipeline_path", ")", ":", "logger", ".", "debug", "(", "f\"Found {pipeline_path}\"", ")", "else", ":", "raise", "PipelineNotFoundError", "(", "f\"{pipeline_name}.yaml not found in \"", "f\"either \"", "f\"{working_directory}/pipelines \"", "f\"or {pypyr_dir}/pipelines\"", ")", "logger", ".", "debug", "(", "\"done\"", ")", "return", "pipeline_path"], "docstring_tokens": ["Look", "for", "the", "pipeline", "in", "the", "various", "places", "it", "could", "be", "."]}
{"code_tokens": ["def", "get_pipeline_definition", "(", "pipeline_name", ",", "working_dir", ")", ":", "logger", ".", "debug", "(", "\"starting\"", ")", "pipeline_path", "=", "get_pipeline_path", "(", "pipeline_name", "=", "pipeline_name", ",", "working_directory", "=", "working_dir", ")", "logger", ".", "debug", "(", "f\"Trying to open pipeline at path {pipeline_path}\"", ")", "try", ":", "with", "open", "(", "pipeline_path", ")", "as", "yaml_file", ":", "pipeline_definition", "=", "pypyr", ".", "yaml", ".", "get_pipeline_yaml", "(", "yaml_file", ")", "logger", ".", "debug", "(", "f\"found {len(pipeline_definition)} stages in pipeline.\"", ")", "except", "FileNotFoundError", ":", "logger", ".", "error", "(", "\"The pipeline doesn't exist. Looking for a file here: \"", "f\"{pipeline_name}.yaml in the /pipelines sub directory.\"", ")", "raise", "logger", ".", "debug", "(", "\"pipeline definition loaded\"", ")", "logger", ".", "debug", "(", "\"done\"", ")", "return", "pipeline_definition"], "docstring_tokens": ["Open", "and", "parse", "the", "pipeline", "definition", "yaml", "."]}
{"code_tokens": ["def", "to_yaml", "(", "cls", ",", "representer", ",", "node", ")", ":", "return", "representer", ".", "represent_scalar", "(", "cls", ".", "yaml_tag", ",", "node", ".", "value", ")"], "docstring_tokens": ["How", "to", "serialize", "this", "class", "back", "to", "yaml", "."]}
{"code_tokens": ["def", "get_value", "(", "self", ",", "context", ")", ":", "if", "self", ".", "value", ":", "return", "expressions", ".", "eval_string", "(", "self", ".", "value", ",", "context", ")", "else", ":", "# Empty input raises cryptic EOF syntax err, this more human", "# friendly", "raise", "ValueError", "(", "'!py string expression is empty. It must be a '", "'valid python expression instead.'", ")"], "docstring_tokens": ["Run", "python", "eval", "on", "the", "input", "string", "."]}
{"code_tokens": ["def", "foreach_loop", "(", "self", ",", "context", ")", ":", "logger", ".", "debug", "(", "\"starting\"", ")", "# Loop decorators only evaluated once, not for every step repeat", "# execution.", "foreach", "=", "context", ".", "get_formatted_iterable", "(", "self", ".", "foreach_items", ")", "foreach_length", "=", "len", "(", "foreach", ")", "logger", ".", "info", "(", "f\"foreach decorator will loop {foreach_length} times.\"", ")", "for", "i", "in", "foreach", ":", "logger", ".", "info", "(", "f\"foreach: running step {i}\"", ")", "# the iterator must be available to the step when it executes", "context", "[", "'i'", "]", "=", "i", "# conditional operators apply to each iteration, so might be an", "# iteration run, skips or swallows.", "self", ".", "run_conditional_decorators", "(", "context", ")", "logger", ".", "debug", "(", "f\"foreach: done step {i}\"", ")", "logger", ".", "debug", "(", "f\"foreach decorator looped {foreach_length} times.\"", ")", "logger", ".", "debug", "(", "\"done\"", ")"], "docstring_tokens": ["Run", "step", "once", "for", "each", "item", "in", "foreach_items", "."]}
